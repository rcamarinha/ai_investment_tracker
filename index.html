<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Financial Advisor</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            color: #fff;
            padding: 20px;
            min-height: 100vh;
        }
        .container { max-width: 1200px; margin: 0 auto; }
        .header {
            background: linear-gradient(90deg, #2563eb 0%, #7c3aed 100%);
            padding: 30px;
            border-radius: 20px;
            margin-bottom: 20px;
        }
        .header h1 { font-size: 28px; margin-bottom: 10px; }
        .header p { color: #bfdbfe; font-size: 14px; }
        .card {
            background: #1e293b;
            border: 1px solid #334155;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
        }
        .portfolio-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }
        .total-value { text-align: right; }
        .total-value div:first-child { color: #94a3b8; font-size: 12px; }
        .total-value div:last-child { color: #4ade80; font-size: 24px; font-weight: bold; }
        .positions {
            display: block;
            margin-bottom: 20px;
        }
        .position {
            background: #334155;
            border: 1px solid #475569;
            border-radius: 0;
            padding: 12px 15px;
            margin-bottom: 1px;
            display: grid;
            grid-template-columns: 100px 180px 90px 70px 100px 100px 100px 100px 70px 120px;
            gap: 15px;
            align-items: center;
            font-size: 13px;
        }
        .position:first-child {
            border-radius: 10px 10px 0 0;
        }
        .position:last-child {
            border-radius: 0 0 10px 10px;
            margin-bottom: 0;
        }
        .position-header-row {
            background: #1e293b;
            border: 1px solid #475569;
            border-radius: 10px 10px 0 0;
            padding: 12px 15px;
            display: grid;
            grid-template-columns: 100px 180px 90px 70px 100px 100px 100px 100px 70px 120px;
            gap: 15px;
            align-items: center;
            font-size: 11px;
            font-weight: bold;
            color: #94a3b8;
            text-transform: uppercase;
        }
        .position-symbol { font-size: 15px; font-weight: bold; color: #fff; }
        .position-details { color: #cbd5e1; }
        .position-value { color: #60a5fa; font-weight: bold; }
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 15px;
            cursor: pointer;
            font-weight: 600;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        .btn-add { background: #2563eb; color: white; }
        .btn-analyze { 
            background: linear-gradient(90deg, #7c3aed 0%, #2563eb 100%);
            color: white;
        }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .analysis-section { margin-top: 20px; }
        .analysis-card {
            background: #334155;
            border: 1px solid #475569;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 15px;
        }
        .analysis-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .analysis-content { color: #cbd5e1; line-height: 1.6; }
        .idea-item {
            background: #475569;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 10px;
        }
        .idea-title { font-weight: bold; margin-bottom: 8px; }
        .idea-desc { color: #cbd5e1; font-size: 14px; }
        .disclaimer {
            background: rgba(251, 191, 36, 0.1);
            border: 1px solid rgba(251, 191, 36, 0.3);
            color: #fcd34d;
            padding: 15px;
            border-radius: 8px;
            font-size: 13px;
            margin-top: 15px;
        }
        .perspective-selector {
            background: #1e293b;
            border: 1px solid #334155;
            border-radius: 12px;
            padding: 20px;
            margin-top: 15px;
        }
        .perspective-header {
            margin-bottom: 12px;
        }
        .perspective-label {
            color: #94a3b8;
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .perspective-tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 15px;
        }
        .perspective-tab {
            padding: 8px 16px;
            border-radius: 8px;
            border: 2px solid #475569;
            background: #0f172a;
            color: #94a3b8;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .perspective-tab:hover {
            border-color: #64748b;
            color: #cbd5e1;
            background: #1e293b;
        }
        .perspective-tab.active {
            color: white;
            background: #1e293b;
        }
        .perspective-info {
            background: #0f172a;
            border-radius: 8px;
            padding: 12px 16px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .perspective-info-icon {
            font-size: 24px;
        }
        .perspective-info-text {
            flex: 1;
        }
        .perspective-info-name {
            color: #e2e8f0;
            font-weight: 700;
            font-size: 15px;
            margin-bottom: 2px;
        }
        .perspective-info-desc {
            color: #cbd5e1;
            font-size: 13px;
            line-height: 1.5;
            margin-bottom: 4px;
        }
        .perspective-info-figures {
            color: #94a3b8;
            font-size: 12px;
        }
        .perspective-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            color: white;
        }
        .perspective-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        .btn-trade-ideas {
            background: linear-gradient(135deg, #059669 0%, #10b981 100%);
        }
        .btn-trade-ideas:hover {
            background: linear-gradient(135deg, #047857 0%, #059669 100%);
        }
        .trade-ideas-section {
            margin-top: 20px;
        }
        .trade-idea-card {
            background: #334155;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 15px;
            border-left: 4px solid;
        }
        .trade-idea-card.rebalance { border-left-color: #f59e0b; }
        .trade-idea-card.buy { border-left-color: #10b981; }
        .trade-idea-card.sell { border-left-color: #ef4444; }
        .trade-idea-card.hold { border-left-color: #6366f1; }
        .trade-idea-card.watch { border-left-color: #8b5cf6; }
        .trade-idea-header {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            margin-bottom: 12px;
        }
        .trade-idea-number {
            background: #1e293b;
            color: #e2e8f0;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 14px;
            flex-shrink: 0;
        }
        .trade-idea-title-section {
            flex: 1;
        }
        .trade-idea-title {
            color: #e2e8f0;
            font-size: 16px;
            font-weight: 700;
            margin-bottom: 4px;
        }
        .trade-idea-subtitle {
            color: #94a3b8;
            font-size: 13px;
        }
        .trade-idea-context {
            background: #1e293b;
            border-radius: 8px;
            padding: 12px 15px;
            margin-bottom: 12px;
        }
        .trade-idea-context h4 {
            color: #94a3b8;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }
        .trade-idea-context ul {
            margin: 0;
            padding-left: 18px;
            color: #cbd5e1;
            font-size: 13px;
            line-height: 1.6;
        }
        .trade-idea-action {
            background: #0f172a;
            border-radius: 8px;
            padding: 12px 15px;
            margin-bottom: 12px;
            border: 1px solid #334155;
        }
        .trade-idea-action h4 {
            color: #10b981;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .trade-idea-action p {
            color: #e2e8f0;
            font-size: 14px;
            line-height: 1.6;
            margin: 0;
        }
        .trade-idea-rationale {
            color: #94a3b8;
            font-size: 13px;
            line-height: 1.6;
            font-style: italic;
        }
        .trade-ideas-summary {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            border: 1px solid #334155;
            border-radius: 12px;
            padding: 20px;
            margin-top: 15px;
        }
        .trade-ideas-summary h3 {
            color: #e2e8f0;
            font-size: 16px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .execution-step {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            padding: 10px 0;
            border-bottom: 1px solid #334155;
        }
        .execution-step:last-child {
            border-bottom: none;
        }
        .execution-time {
            background: #334155;
            color: #94a3b8;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            white-space: nowrap;
        }
        .execution-action {
            color: #cbd5e1;
            font-size: 13px;
            line-height: 1.5;
        }
        .allocation-section {
            background: #1e293b;
            border: 1px solid #334155;
            border-radius: 12px;
            padding: 20px;
            margin-top: 15px;
        }
        .allocation-charts {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
        }
        .allocation-chart-container {
            background: #0f172a;
            border-radius: 8px;
            padding: 15px;
        }
        .allocation-chart {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .allocation-bar-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .allocation-bar-label {
            width: 100px;
            font-size: 12px;
            color: #cbd5e1;
            text-align: right;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .allocation-bar-track {
            flex: 1;
            height: 24px;
            background: #334155;
            border-radius: 4px;
            overflow: hidden;
        }
        .allocation-bar-fill {
            height: 100%;
            border-radius: 4px;
            display: flex;
            align-items: center;
            padding-left: 8px;
            font-size: 11px;
            font-weight: 600;
            color: white;
            transition: width 0.3s ease;
        }
        .allocation-bar-value {
            width: 60px;
            font-size: 12px;
            color: #94a3b8;
            text-align: right;
        }
        .market-news-card {
            border-left: 3px solid #60a5fa;
        }
        .trade-idea {
            background: #475569;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 10px;
        }
        .trade-idea-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }
        .trade-ticker {
            font-family: monospace;
            font-weight: 700;
            font-size: 15px;
            color: #e2e8f0;
            background: #1e293b;
            padding: 2px 8px;
            border-radius: 4px;
        }
        .trade-action {
            font-size: 11px;
            font-weight: 700;
            padding: 2px 10px;
            border-radius: 12px;
            letter-spacing: 0.5px;
        }
        .trade-title { font-weight: bold; margin-bottom: 6px; color: #e2e8f0; }
        .trade-rationale { color: #cbd5e1; font-size: 13px; line-height: 1.5; }
        .loading { text-align: center; padding: 40px; color: #94a3b8; }
        .empty-state { text-align: center; padding: 60px 20px; color: #64748b; }
        @media (max-width: 768px) {
            .position, .position-header-row {
                grid-template-columns: 1fr 1fr;
                gap: 8px;
                font-size: 12px;
            }
            .portfolio-header { flex-direction: column; align-items: flex-start; }
            .total-value { text-align: left; }
        }
        .auth-bar {
            background: #1e293b;
            border: 1px solid #334155;
            border-radius: 12px;
            padding: 12px 20px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
            font-size: 13px;
        }
        .auth-bar input[type="email"],
        .auth-bar input[type="password"] {
            padding: 8px 12px;
            background: #334155;
            color: white;
            border: 1px solid #475569;
            border-radius: 6px;
            font-size: 13px;
            width: 200px;
        }
        .auth-bar .btn-sm {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
            font-weight: 600;
            color: white;
        }
        @media (max-width: 768px) {
            .auth-bar input[type="email"],
            .auth-bar input[type="password"] {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üìà AI Financial Advisor <span style="font-size: 12px; font-weight: normal; opacity: 0.6;">v3.0.1</span></h1>
            <p>Market analysis and personalized portfolio insights</p>
        </div>
        
        <div id="authBar" class="auth-bar" style="display: none;"></div>

        <!-- Artifact Network Warning (shown only in artifacts) -->
        <div id="artifactWarning" style="display: none; background: #fef3c7; border: 2px solid #f59e0b; border-radius: 10px; padding: 15px; margin-bottom: 20px;">
            <div style="display: flex; align-items: start; gap: 10px;">
                <div style="font-size: 24px;">‚ö†Ô∏è</div>
                <div style="flex: 1;">
                    <div style="font-weight: bold; color: #92400e; margin-bottom: 5px;">Network Restrictions Detected</div>
                    <div style="color: #78350f; font-size: 14px; margin-bottom: 10px;">
                        Claude artifacts cannot fetch live market prices due to network security restrictions.
                    </div>
                    <div style="color: #78350f; font-size: 13px; background: white; padding: 10px; border-radius: 5px; line-height: 1.6;">
                        <strong>üí° Solution: Download & Open Locally</strong><br>
                        ‚Üí Right-click anywhere on this page<br>
                        ‚Üí Select "Save As" ‚Üí Save the HTML file<br>
                        ‚Üí Open the saved file in your browser<br>
                        ‚úì Full price fetching ‚úì Works offline ‚úì Cloud sync when back in Claude
                    </div>
                </div>
            </div>
        </div>

        <div class="card">
            <div class="portfolio-header">
                <h2>üíº Your Portfolio</h2>
                <div class="total-value">
                    <div>Total Value</div>
                    <div id="totalValue">$0</div>
                </div>
            </div>

            <div class="positions" id="positions"></div>

            <div>
                <button class="btn btn-add" onclick="showApiKeyDialog()" style="background: #7c3aed;">üîë API Keys</button>
                <button class="btn btn-add" onclick="showImportDialog()">üìã Import Portfolio from Spreadsheet</button>
                <button class="btn btn-add" onclick="fetchMarketPrices()" id="refreshBtn" style="background: #059669;">üîÑ Update Prices</button>
                <button class="btn btn-add" onclick="savePortfolioSnapshot()" style="background: #f59e0b;">üíæ Save Snapshot</button>
            </div>

            <div id="allocationSection" class="allocation-section" style="display: none;">
                <h3 style="color: #e2e8f0; margin-bottom: 15px;">üìä Portfolio Allocation</h3>
                <div class="allocation-charts">
                    <div class="allocation-chart-container">
                        <h4 style="color: #94a3b8; font-size: 12px; text-transform: uppercase; margin-bottom: 10px;">By Asset Type</h4>
                        <div id="typeAllocationChart" class="allocation-chart"></div>
                    </div>
                    <div class="allocation-chart-container">
                        <h4 style="color: #94a3b8; font-size: 12px; text-transform: uppercase; margin-bottom: 10px;">By Sector</h4>
                        <div id="sectorAllocationChart" class="allocation-chart"></div>
                    </div>
                </div>
            </div>

            <div class="perspective-selector" id="perspectiveSelector">
                <div class="perspective-header">
                    <span class="perspective-label">Investment Perspective:</span>
                </div>
                <div class="perspective-tabs" id="perspectiveTabs"></div>
                <div class="perspective-info" id="perspectiveInfo"></div>
                <div class="perspective-buttons">
                    <button class="btn btn-analyze" onclick="analyzeMarkets()" id="analyzeBtn">Get AI Analysis</button>
                    <button class="btn btn-trade-ideas" onclick="getTradeIdeas()" id="tradeIdeasBtn">üíπ Get Trade Ideas</button>
                </div>
            </div>
        </div>

        <div id="apiKeyDialog" style="display: none;">
            <div class="card">
                <h2 style="margin-bottom: 15px;">üîë API Key Management</h2>
                
                <div style="background: #1e293b; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                    <h3 style="color: #cbd5e1; margin-bottom: 10px; font-size: 16px;">3-Tier Strategy:</h3>
                    <div style="color: #94a3b8; font-size: 13px; line-height: 1.8;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                            <span>üöÄ <strong>Finnhub:</strong> 60 calls/minute (unlimited daily)</span>
                            <span style="color: #4ade80;">PRIMARY</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                            <span>‚ö° <strong>FMP:</strong> 250 calls/day (no per-min limit)</span>
                            <span style="color: #60a5fa;">FALLBACK #1</span>
                        </div>
                        <div style="display: flex; justify-content: space-between;">
                            <span>üîÑ <strong>Alpha Vantage:</strong> 5 calls/min, 25/day</span>
                            <span style="color: #f59e0b;">FALLBACK #2</span>
                        </div>
                    </div>
                    <div style="margin-top: 10px; padding: 10px; background: #0f172a; border-radius: 6px; font-size: 12px; color: #94a3b8;">
                        üí° <strong>Strategy:</strong> Finnhub primary (fast), FMP for what it misses (generous limit), Alpha Vantage last resort (strict limits)
                    </div>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <label style="display: block; color: #cbd5e1; margin-bottom: 8px; font-weight: bold;">
                        üöÄ Finnhub API Key (Primary - Fast & Unlimited)
                    </label>
                    <input 
                        type="text" 
                        id="finnhubKeyInput" 
                        placeholder="Enter your Finnhub API key" 
                        style="width: 100%; padding: 12px; background: #334155; color: white; border: 1px solid #475569; border-radius: 8px; font-family: monospace; font-size: 13px; margin-bottom: 8px;"
                    />
                    <div style="color: #94a3b8; font-size: 12px;">
                        Get free key: <a href="https://finnhub.io/register" target="_blank" style="color: #60a5fa;">https://finnhub.io/register</a>
                        <br>‚úì 60 calls/minute ‚Ä¢ ‚úì Unlimited daily ‚Ä¢ ‚úì Best for US stocks
                    </div>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <label style="display: block; color: #cbd5e1; margin-bottom: 8px; font-weight: bold;">
                        ‚ö° Financial Modeling Prep API Key (Fallback #1 - Generous Limit)
                    </label>
                    <input 
                        type="text" 
                        id="fmpKeyInput" 
                        placeholder="Enter your FMP API key" 
                        style="width: 100%; padding: 12px; background: #334155; color: white; border: 1px solid #475569; border-radius: 8px; font-family: monospace; font-size: 13px; margin-bottom: 8px;"
                    />
                    <div style="color: #94a3b8; font-size: 12px;">
                        Get free key: <a href="https://site.financialmodelingprep.com/developer/docs/" target="_blank" style="color: #60a5fa;">https://financialmodelingprep.com</a>
                        <br>‚úì 250 calls/day ‚Ä¢ ‚úì Using quote-short endpoint (better free tier support)
                    </div>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <label style="display: block; color: #cbd5e1; margin-bottom: 8px; font-weight: bold;">
                        üîÑ Alpha Vantage API Key (Fallback #2 - Last Resort)
                    </label>
                    <input 
                        type="text" 
                        id="alphaVantageKeyInput" 
                        placeholder="Enter your Alpha Vantage API key" 
                        style="width: 100%; padding: 12px; background: #334155; color: white; border: 1px solid #475569; border-radius: 8px; font-family: monospace; font-size: 13px; margin-bottom: 8px;"
                    />
                    <div style="color: #94a3b8; font-size: 12px;">
                        Get free key: <a href="https://www.alphavantage.co/support/#api-key" target="_blank" style="color: #60a5fa;">https://www.alphavantage.co/support/#api-key</a>
                        <br>‚úì 5 calls/minute, 25/day ‚Ä¢ ‚úì Good international coverage ‚Ä¢ ‚úì Use sparingly
                    </div>
                </div>
                
                <hr style="border: 1px solid #334155; margin: 20px 0;">

                <div style="margin-bottom: 20px;">
                    <label style="display: block; color: #cbd5e1; margin-bottom: 8px; font-weight: bold;">
                        ü§ñ Anthropic API Key (AI Analysis)
                    </label>
                    <input
                        type="password"
                        id="anthropicKeyInput"
                        placeholder="Enter your Anthropic API key (sk-ant-...)"
                        style="width: 100%; padding: 12px; background: #334155; color: white; border: 1px solid #475569; border-radius: 8px; font-family: monospace; font-size: 13px; margin-bottom: 8px;"
                    />
                    <div style="color: #94a3b8; font-size: 12px;">
                        Get API key: <a href="https://console.anthropic.com/settings/keys" target="_blank" style="color: #60a5fa;">https://console.anthropic.com/settings/keys</a>
                        <br>Required for "Get AI Analysis" when running outside Claude.ai
                    </div>
                </div>

                <hr style="border: 1px solid #334155; margin: 20px 0;">

                <div style="margin-bottom: 20px;">
                    <label style="display: block; color: #cbd5e1; margin-bottom: 8px; font-weight: bold;">
                        ‚òÅÔ∏è Supabase Project URL (Cloud Database)
                    </label>
                    <input
                        type="text"
                        id="supabaseUrlInput"
                        placeholder="https://your-project.supabase.co"
                        style="width: 100%; padding: 12px; background: #334155; color: white; border: 1px solid #475569; border-radius: 8px; font-family: monospace; font-size: 13px; margin-bottom: 8px;"
                    />
                    <div style="color: #94a3b8; font-size: 12px;">
                        Get from: <a href="https://supabase.com/dashboard" target="_blank" style="color: #60a5fa;">Supabase Dashboard</a> &gt; Settings &gt; API
                    </div>
                </div>

                <div style="margin-bottom: 20px;">
                    <label style="display: block; color: #cbd5e1; margin-bottom: 8px; font-weight: bold;">
                        üîë Supabase Anon Key (Public)
                    </label>
                    <input
                        type="text"
                        id="supabaseAnonKeyInput"
                        placeholder="eyJhbGciOiJIUzI1NiIs..."
                        style="width: 100%; padding: 12px; background: #334155; color: white; border: 1px solid #475569; border-radius: 8px; font-family: monospace; font-size: 13px; margin-bottom: 8px;"
                    />
                    <div style="color: #94a3b8; font-size: 12px;">
                        This is the <strong>anon/public</strong> key (safe for browser use). Row Level Security protects your data.
                    </div>
                </div>

                <div style="background: #fef3c7; border: 1px solid #f59e0b; border-radius: 8px; padding: 12px; margin-bottom: 20px;">
                    <div style="color: #92400e; font-size: 13px;">
                        <strong>üîí Security:</strong> API keys saved in your browser only (localStorage). Supabase anon key is safe for public use.
                        <br><br>
                        <strong>üìä Coverage:</strong> All 3 price APIs combined = ~98%+ success rate. Finnhub ~85%, FMP ~10%, Alpha Vantage ~5%.
                    </div>
                </div>
                
                <div style="display: flex; gap: 10px;">
                    <button class="btn btn-analyze" onclick="saveApiKeys()">üíæ Save Keys</button>
                    <button class="btn btn-add" onclick="closeApiKeyDialog()">Cancel</button>
                    <button class="btn btn-add" onclick="clearApiKeys()" style="background: #dc2626; margin-left: auto;">üóëÔ∏è Clear All Keys</button>
                </div>
            </div>
        </div>

        <div id="importDialog" style="display: none;">
            <div class="card">
                <h2 style="margin-bottom: 15px;">üìã Import Positions</h2>
                <p style="color: #cbd5e1; margin-bottom: 15px;">
                    Paste your positions directly from your spreadsheet - including all columns. The app will automatically extract the Ticker, Units, and Avg Unit Price.
                </p>
                <p style="color: #94a3b8; font-size: 13px; margin-bottom: 10px;">
                    ‚úÖ Just copy your entire spreadsheet rows and paste them here!<br>
                    ‚úÖ Works with Excel, Google Sheets, Numbers<br>
                    ‚úÖ Header row is automatically detected and skipped
                </p>
                <textarea id="importText" placeholder="Paste your spreadsheet data here (with or without headers)..." style="width: 100%; height: 200px; padding: 15px; background: #334155; color: white; border: 1px solid #475569; border-radius: 8px; font-family: monospace; font-size: 12px; margin-bottom: 15px;"></textarea>
                <div>
                    <button class="btn btn-analyze" onclick="importPositions()">Import Positions</button>
                    <button class="btn btn-add" onclick="closeImportDialog()">Cancel</button>
                </div>
            </div>
        </div>

        <div id="analysisSection"></div>
        
        <div id="historySection" style="display: none;">
            <div class="card">
                <h2 style="margin-bottom: 15px;">üìà Portfolio History</h2>
                <div id="historyChart" style="margin-bottom: 20px;"></div>
                <div id="historyLog"></div>
            </div>
        </div>
    </div>

    <script>
        console.log('=== SCRIPT STARTING TO LOAD ===');
        console.log('Script tag found and executing');
        
        let portfolio = [];
        let marketPrices = {}; // Store current market prices
        let priceMetadata = {}; // Store {timestamp, source, success} for each symbol
        let pricesLoading = false;
        let alphaVantageKey = ''; // loaded from DB after login
        let finnhubKey = ''; // loaded from DB after login
        let fmpKey = ''; // loaded from DB after login
        let anthropicKey = ''; // For AI analysis outside Claude.ai ‚Äî users enter their own key
        let portfolioHistory = []; // Array of {timestamp, totalInvested, totalMarketValue, positions}
        let supabaseUrl = 'https://dybetrrhshqezokcxiid.supabase.co';
        let supabaseAnonKey = 'sb_publishable_1exZf5F28-XEl-AxelyxEQ_Yb6WEQMz';
        let supabaseClient = null;
        let currentUser = null;
        let selectedPerspective = 'value'; // Default investment perspective
        let sectorCache = {}; // Cache for sector lookups {symbol: sector}
        let assetDatabase = {}; // DB-backed asset metadata {ticker: {name, ticker, stockExchange, sector, currency, assetType}}

        // Static sector mapping for common tickers (no API needed)
        const SECTOR_MAPPING = {
            // Technology
            AAPL: 'Technology', MSFT: 'Technology', GOOGL: 'Technology', GOOG: 'Technology',
            META: 'Technology', AMZN: 'Technology', NVDA: 'Technology', AMD: 'Technology',
            INTC: 'Technology', CRM: 'Technology', ORCL: 'Technology', ADBE: 'Technology',
            CSCO: 'Technology', IBM: 'Technology', QCOM: 'Technology', TXN: 'Technology',
            AVGO: 'Technology', NOW: 'Technology', INTU: 'Technology', AMAT: 'Technology',
            MU: 'Technology', LRCX: 'Technology', KLAC: 'Technology', SNPS: 'Technology',
            CDNS: 'Technology', MRVL: 'Technology', NXPI: 'Technology', ASML: 'Technology',
            TSM: 'Technology', ARM: 'Technology', PLTR: 'Technology', SNOW: 'Technology',
            // Healthcare
            JNJ: 'Healthcare', UNH: 'Healthcare', PFE: 'Healthcare', ABBV: 'Healthcare',
            MRK: 'Healthcare', LLY: 'Healthcare', TMO: 'Healthcare', ABT: 'Healthcare',
            DHR: 'Healthcare', BMY: 'Healthcare', AMGN: 'Healthcare', GILD: 'Healthcare',
            MDT: 'Healthcare', CVS: 'Healthcare', ISRG: 'Healthcare', VRTX: 'Healthcare',
            REGN: 'Healthcare', SYK: 'Healthcare', ZTS: 'Healthcare', BDX: 'Healthcare',
            CI: 'Healthcare', HUM: 'Healthcare', ELV: 'Healthcare', MCK: 'Healthcare',
            // Financial Services
            JPM: 'Financial', BAC: 'Financial', WFC: 'Financial', GS: 'Financial',
            MS: 'Financial', C: 'Financial', BLK: 'Financial', SCHW: 'Financial',
            AXP: 'Financial', SPGI: 'Financial', CME: 'Financial', ICE: 'Financial',
            USB: 'Financial', PNC: 'Financial', TFC: 'Financial', COF: 'Financial',
            BK: 'Financial', STT: 'Financial', AIG: 'Financial', MET: 'Financial',
            PRU: 'Financial', AFL: 'Financial', ALL: 'Financial', TRV: 'Financial',
            V: 'Financial', MA: 'Financial', PYPL: 'Financial', SQ: 'Financial',
            // Consumer Discretionary
            TSLA: 'Consumer Discretionary', HD: 'Consumer Discretionary', NKE: 'Consumer Discretionary',
            MCD: 'Consumer Discretionary', SBUX: 'Consumer Discretionary', LOW: 'Consumer Discretionary',
            TJX: 'Consumer Discretionary', BKNG: 'Consumer Discretionary', MAR: 'Consumer Discretionary',
            CMG: 'Consumer Discretionary', YUM: 'Consumer Discretionary', DPZ: 'Consumer Discretionary',
            ORLY: 'Consumer Discretionary', AZO: 'Consumer Discretionary', ROST: 'Consumer Discretionary',
            DHI: 'Consumer Discretionary', LEN: 'Consumer Discretionary', PHM: 'Consumer Discretionary',
            F: 'Consumer Discretionary', GM: 'Consumer Discretionary', ABNB: 'Consumer Discretionary',
            // Consumer Staples
            PG: 'Consumer Staples', KO: 'Consumer Staples', PEP: 'Consumer Staples',
            COST: 'Consumer Staples', WMT: 'Consumer Staples', PM: 'Consumer Staples',
            MO: 'Consumer Staples', MDLZ: 'Consumer Staples', CL: 'Consumer Staples',
            KMB: 'Consumer Staples', GIS: 'Consumer Staples', K: 'Consumer Staples',
            HSY: 'Consumer Staples', SJM: 'Consumer Staples', CAG: 'Consumer Staples',
            KHC: 'Consumer Staples', STZ: 'Consumer Staples', TAP: 'Consumer Staples',
            // Energy
            XOM: 'Energy', CVX: 'Energy', COP: 'Energy', EOG: 'Energy',
            SLB: 'Energy', MPC: 'Energy', PSX: 'Energy', VLO: 'Energy',
            OXY: 'Energy', PXD: 'Energy', DVN: 'Energy', HAL: 'Energy',
            BKR: 'Energy', FANG: 'Energy', HES: 'Energy', MRO: 'Energy',
            TTE: 'Energy', BP: 'Energy', SHEL: 'Energy', RDS: 'Energy',
            // Industrials
            CAT: 'Industrials', DE: 'Industrials', BA: 'Industrials', HON: 'Industrials',
            UNP: 'Industrials', RTX: 'Industrials', LMT: 'Industrials', GE: 'Industrials',
            MMM: 'Industrials', UPS: 'Industrials', FDX: 'Industrials', CSX: 'Industrials',
            NSC: 'Industrials', WM: 'Industrials', RSG: 'Industrials', EMR: 'Industrials',
            ITW: 'Industrials', ETN: 'Industrials', PH: 'Industrials', ROK: 'Industrials',
            // Materials
            LIN: 'Materials', APD: 'Materials', SHW: 'Materials', ECL: 'Materials',
            FCX: 'Materials', NEM: 'Materials', NUE: 'Materials', DOW: 'Materials',
            DD: 'Materials', PPG: 'Materials', VMC: 'Materials', MLM: 'Materials',
            // Utilities
            NEE: 'Utilities', DUK: 'Utilities', SO: 'Utilities', D: 'Utilities',
            AEP: 'Utilities', EXC: 'Utilities', SRE: 'Utilities', XEL: 'Utilities',
            ED: 'Utilities', WEC: 'Utilities', ES: 'Utilities', AWK: 'Utilities',
            // Real Estate
            PLD: 'Real Estate', AMT: 'Real Estate', CCI: 'Real Estate', EQIX: 'Real Estate',
            SPG: 'Real Estate', PSA: 'Real Estate', O: 'Real Estate', WELL: 'Real Estate',
            DLR: 'Real Estate', AVB: 'Real Estate', EQR: 'Real Estate', VTR: 'Real Estate',
            // Communication Services
            DIS: 'Communication', NFLX: 'Communication', CMCSA: 'Communication', T: 'Communication',
            VZ: 'Communication', TMUS: 'Communication', CHTR: 'Communication', EA: 'Communication',
            TTWO: 'Communication', ATVI: 'Communication', WBD: 'Communication', PARA: 'Communication',
            // ETFs - categorize by their focus
            SPY: 'Index ETF', VOO: 'Index ETF', IVV: 'Index ETF', VTI: 'Index ETF',
            QQQ: 'Tech ETF', VGT: 'Tech ETF', XLK: 'Tech ETF', ARKK: 'Tech ETF',
            XLF: 'Financial ETF', VFH: 'Financial ETF', KRE: 'Financial ETF',
            XLE: 'Energy ETF', VDE: 'Energy ETF', OIH: 'Energy ETF',
            XLV: 'Healthcare ETF', VHT: 'Healthcare ETF', IBB: 'Healthcare ETF',
            XLY: 'Consumer ETF', VCR: 'Consumer ETF',
            XLP: 'Consumer ETF', VDC: 'Consumer ETF',
            XLI: 'Industrial ETF', VIS: 'Industrial ETF',
            XLU: 'Utilities ETF', VPU: 'Utilities ETF',
            XLRE: 'Real Estate ETF', VNQ: 'Real Estate ETF',
            XLB: 'Materials ETF', VAW: 'Materials ETF',
            BND: 'Bond ETF', AGG: 'Bond ETF', TLT: 'Bond ETF', LQD: 'Bond ETF',
            HYG: 'Bond ETF', JNK: 'Bond ETF', VCIT: 'Bond ETF', VCSH: 'Bond ETF',
            GLD: 'Commodity ETF', SLV: 'Commodity ETF', IAU: 'Commodity ETF',
            VWO: 'Intl ETF', EFA: 'Intl ETF', IEFA: 'Intl ETF', VEA: 'Intl ETF',
            EEM: 'Emerging ETF', VWO: 'Emerging ETF', IEMG: 'Emerging ETF',
            // Crypto
            BTC: 'Crypto', ETH: 'Crypto', SOL: 'Crypto', ADA: 'Crypto',
            DOGE: 'Crypto', XRP: 'Crypto', DOT: 'Crypto', AVAX: 'Crypto',
            GBTC: 'Crypto', ETHE: 'Crypto', BITO: 'Crypto',
            // European stocks (common ones)
            'MC.PA': 'Consumer Discretionary', 'OR.PA': 'Consumer Staples', 'SAN.PA': 'Healthcare',
            'AIR.PA': 'Industrials', 'TTE.PA': 'Energy', 'BNP.PA': 'Financial',
            'ASML.AS': 'Technology', 'ADYEN.AS': 'Technology', 'PRX.AS': 'Technology',
            'SAP.DE': 'Technology', 'SIE.DE': 'Industrials', 'ALV.DE': 'Financial',
            'NESN.SW': 'Consumer Staples', 'ROG.SW': 'Healthcare', 'NOVN.SW': 'Healthcare',
            'SHEL.L': 'Energy', 'AZN.L': 'Healthcare', 'HSBA.L': 'Financial'
        };

        // Get sector for a symbol - checks DB-backed assetDatabase first, then static mapping, then cache
        function getSector(symbol) {
            if (!symbol) return 'Other';
            const upperSymbol = symbol.toUpperCase();

            // Check DB-backed asset database first (fastest, user-specific)
            if (assetDatabase[upperSymbol] && assetDatabase[upperSymbol].sector) {
                return assetDatabase[upperSymbol].sector;
            }

            // Check static mapping (no API needed)
            if (SECTOR_MAPPING[upperSymbol]) {
                return SECTOR_MAPPING[upperSymbol];
            }

            // Check cache (from previous API lookups)
            if (sectorCache[upperSymbol]) {
                return sectorCache[upperSymbol];
            }

            // Return 'Other' for unknown symbols
            return 'Other';
        }

        // Load sector cache from localStorage on startup
        function loadSectorCache() {
            try {
                const cached = localStorage.getItem('sectorCache');
                if (cached) {
                    sectorCache = JSON.parse(cached);
                    console.log('Loaded sector cache with', Object.keys(sectorCache).length, 'entries');
                }
            } catch (e) {
                console.warn('Failed to load sector cache:', e);
                sectorCache = {};
            }
        }

        // Save sector cache to localStorage
        function saveSectorCache() {
            try {
                localStorage.setItem('sectorCache', JSON.stringify(sectorCache));
            } catch (e) {
                console.warn('Failed to save sector cache:', e);
            }
        }

        // Investment perspective definitions
        const INVESTMENT_PERSPECTIVES = {
            value: {
                name: 'Value Investing',
                icon: 'üìö',
                color: '#059669',
                figures: 'Benjamin Graham, Warren Buffett, Charlie Munger',
                description: 'Buy securities trading below intrinsic value with a margin of safety. Seek statistical cheapness or wonderful businesses at fair prices.',
                prompt: `You are analyzing this portfolio from the perspective of Classic Value Investing (Deep Intrinsic Value).

Core Philosophy: Buy securities trading below intrinsic value with a margin of safety.

Apply these lenses:
- Graham style: Look for statistical cheapness (low P/B ratios, net-net situations, earnings yield vs bond yields)
- Buffett/Munger style: Identify high-quality businesses at fair prices with durable competitive advantages (moats)
- Greenblatt's Magic Formula: Consider earnings yield and return on capital
- Emphasize margin of safety, circle of competence, and long-term holding periods
- Flag any positions that seem overvalued relative to intrinsic value estimates
- Recommend positions that may benefit from a value-oriented approach`
            },
            garp: {
                name: 'Growth at Reasonable Price',
                icon: 'üå±',
                color: '#2563eb',
                figures: 'Peter Lynch',
                description: 'Find companies growing earnings fast but not at absurd valuations. Buy what you understand before Wall Street catches on.',
                prompt: `You are analyzing this portfolio from the perspective of Growth at a Reasonable Price (GARP), as championed by Peter Lynch.

Core Philosophy: "Buy what you understand." Focus on companies growing earnings rapidly but not at absurd valuations.

Apply these lenses:
- PEG ratio thinking: growth rate should justify the P/E multiple
- Look for "ten-baggers" ‚Äî scalable businesses before Wall Street fully prices them
- Categorize positions as slow growers, stalwarts, fast growers, cyclicals, turnarounds, or asset plays
- Identify companies with strong earnings growth that are still reasonably priced
- Flag positions where growth expectations may already be fully priced in
- Look for overlooked growth stories the market hasn't recognized yet`
            },
            quant: {
                name: 'Quantitative & Systematic',
                icon: 'üî¢',
                color: '#7c3aed',
                figures: 'Jim Simons, Cliff Asness',
                description: 'Use mathematical models, factor exposure, and statistical patterns to find edge. Data over narratives, risk-adjusted returns over raw gains.',
                prompt: `You are analyzing this portfolio from the perspective of Quantitative & Systematic Investing, as practiced by Jim Simons and Cliff Asness.

Core Philosophy: Use mathematical models, statistical patterns, and factor investing to generate alpha.

Apply these lenses:
- Factor exposure analysis: evaluate portfolio tilt toward value, momentum, size, quality, and low-volatility factors
- Assess portfolio diversification using correlation thinking ‚Äî are positions truly independent bets?
- Identify concentration risks and suggest systematic rebalancing approaches
- Look for momentum signals (positive and negative) in current holdings
- Evaluate risk-adjusted returns rather than absolute returns
- Suggest factor-based portfolio construction improvements
- Consider mean reversion vs trend-following signals`
            },
            macro: {
                name: 'Macro Investing',
                icon: 'üåç',
                color: '#dc2626',
                figures: 'George Soros, Ray Dalio',
                description: 'Position for macroeconomic trends ‚Äî interest rates, currencies, debt cycles, and geopolitical shifts. Think top-down, not bottom-up.',
                prompt: `You are analyzing this portfolio from the perspective of Macro Investing (Top-Down), as practiced by George Soros and Ray Dalio.

Core Philosophy: Position for macroeconomic trends ‚Äî interest rates, currencies, geopolitical shifts, and economic cycles.

Apply these lenses:
- Soros's Reflexivity: How are market participants' beliefs creating self-reinforcing or self-defeating cycles?
- Dalio's Economic Machine: Where are we in the short-term and long-term debt cycles?
- All Weather thinking: How would this portfolio perform across different economic environments (growth/inflation rising/falling)?
- Assess interest rate sensitivity and inflation exposure of each position
- Evaluate geopolitical risks affecting specific holdings
- Consider currency exposure and global macro trends
- Suggest hedging strategies for macro tail risks`
            },
            passive: {
                name: 'Index & Passive',
                icon: 'üìà',
                color: '#f59e0b',
                figures: 'John Bogle',
                description: 'You cannot consistently beat the market ‚Äî own it cheaply. Minimize costs, maximize diversification, and let compounding do the work.',
                prompt: `You are analyzing this portfolio from the perspective of Indexing & Passive Investing, as championed by John Bogle.

Core Philosophy: You cannot consistently beat the market ‚Äî own the market cheaply. Time in market beats timing the market.

Apply these lenses:
- Compare this portfolio's likely performance drag vs a simple total-market index fund
- Calculate implied costs: trading friction, tax inefficiency, and opportunity cost of concentration
- Assess how diversified (or concentrated) this portfolio is compared to a broad market index
- Identify positions that add unnecessary complexity without expected excess return
- Suggest simplification opportunities ‚Äî which positions could be replaced by low-cost index exposure?
- Evaluate the portfolio's tracking error relative to major benchmarks
- Consider tax-loss harvesting opportunities within a passive framework`
            },
            technical: {
                name: 'Technical & Momentum',
                icon: 'üìâ',
                color: '#ec4899',
                figures: 'Jesse Livermore, Paul Tudor Jones',
                description: 'Price action contains information. Identify trends, ride momentum, cut losers short, and let winners run.',
                prompt: `You are analyzing this portfolio from the perspective of Technical & Momentum Investing, as practiced by Jesse Livermore and Paul Tudor Jones.

Core Philosophy: Price action contains information. Identify and ride trends. Cut losses short and let winners run.

Apply these lenses:
- Assess which positions are likely in uptrends vs downtrends based on recent price action
- Identify positions that may be breaking out of consolidation patterns
- Flag positions showing momentum deterioration (potential trend reversals)
- Apply the "cut losers, ride winners" principle ‚Äî which positions should be trimmed or added to?
- Consider relative strength ‚Äî which holdings are outperforming or underperforming the market?
- Look for potential support/resistance levels and suggest entry/exit timing
- Evaluate position sizing based on volatility and risk management principles`
            }
        };

        // Check if we're in a Claude artifact (restricted network)
        const isArtifact = window.location.hostname.includes('claude.ai') && 
                          window.location.pathname.includes('artifacts');
        
        // Helper function to fetch stock prices with optimal 3-tier strategy
        // Tier 1: Finnhub (60/min - fastest, no daily limit)
        // Tier 2: FMP (250/day - generous daily limit, no per-min limit)
        // Tier 3: Alpha Vantage (5/min, 25/day - use sparingly)
        async function fetchStockPrice(symbol) {
            console.log(`Fetching price for ${symbol}...`);
            
            // TIER 1: Finnhub (PRIMARY - fastest with no daily limit)
            if (finnhubKey) {
                try {
                    const url = `https://finnhub.io/api/v1/quote?symbol=${symbol}&token=${finnhubKey}`;
                    const response = await fetch(url);
                    
                    if (response.ok) {
                        const data = await response.json();
                        if (data.c && data.c > 0) { // c = current price
                            console.log(`‚úì ${symbol}: $${data.c} (Finnhub)`);
                            return { 
                                price: data.c, 
                                source: 'Finnhub',
                                tier: 1,
                                success: true 
                            };
                        }
                    }
                } catch (err) {
                    console.log(`Finnhub failed for ${symbol}:`, err.message);
                }
            }
            
            // TIER 2: Financial Modeling Prep (FALLBACK #1 - generous daily limit)
            // Using quote-short endpoint - better free tier support
            if (fmpKey) {
                try {
                    const url = `https://financialmodelingprep.com/stable/quote-short?symbol=${symbol}&apikey=${fmpKey}`;
                    console.log(`Trying FMP for ${symbol}...`);
                    const response = await fetch(url);
                    
                    if (response.ok) {
                        const data = await response.json();
                        
                        // Check for error in response
                        if (data.error) {
                            console.log(`FMP API error for ${symbol}:`, data.error);
                        } else if (data && Array.isArray(data) && data.length > 0) {
                            const quote = data[0];
                            if (quote.price && quote.price > 0) {
                                const price = quote.price;
                                console.log(`‚úì ${symbol}: $${price} (FMP)`);
                                return { 
                                    price: price, 
                                    source: 'Financial Modeling Prep',
                                    tier: 2,
                                    success: true 
                                };
                            } else {
                                console.log(`FMP returned data but no valid price for ${symbol}`);
                            }
                        } else {
                            console.log(`FMP returned empty/invalid data for ${symbol}`);
                        }
                    } else if (response.status === 403) {
                        console.log(`FMP 403 for ${symbol}`);
                        if (!window.fmpKeyWarningShown) {
                            window.fmpKeyWarningShown = true;
                            console.warn('‚ö†Ô∏è FMP 403 - Check API key');
                        }
                    } else if (response.status === 429) {
                        console.log(`‚ö†Ô∏è FMP rate limit hit for ${symbol}`);
                    } else {
                        console.log(`FMP HTTP ${response.status} for ${symbol}`);
                    }
                } catch (err) {
                    console.log(`FMP failed for ${symbol}:`, err.message);
                }
                // Falls through to Alpha Vantage if FMP didn't return a valid price
                console.log(`FMP didn't find price for ${symbol}, trying Alpha Vantage...`);
            }
            
            // TIER 3: Alpha Vantage (FALLBACK #2 - use as last resort due to strict limits)
            if (alphaVantageKey) {
                try {
                    const url = `https://www.alphavantage.co/query?function=GLOBAL_QUOTE&symbol=${symbol}&apikey=${alphaVantageKey}`;
                    console.log(`Trying Alpha Vantage for ${symbol}...`);
                    const response = await fetch(url);
                    
                    if (response.ok) {
                        const data = await response.json();
                        const quote = data['Global Quote'];
                        
                        if (quote && quote['05. price']) {
                            const price = parseFloat(quote['05. price']);
                            console.log(`‚úì ${symbol}: $${price} (Alpha Vantage)`);
                            return { 
                                price: price, 
                                source: 'Alpha Vantage',
                                tier: 3,
                                success: true 
                            };
                        } else {
                            console.log(`Alpha Vantage returned no price for ${symbol}`);
                        }
                        
                        // Check for rate limit
                        if (data['Note']) {
                            console.log('‚ö†Ô∏è Alpha Vantage rate limit hit');
                            return {
                                price: null,
                                source: 'Alpha Vantage',
                                tier: 3,
                                success: false,
                                error: 'Rate limit (5/min) - wait 12s'
                            };
                        }
                    } else {
                        console.log(`Alpha Vantage HTTP ${response.status} for ${symbol}`);
                    }
                } catch (err) {
                    console.log(`Alpha Vantage failed for ${symbol}:`, err.message);
                }
            }
            
            // All tiers failed
            const availableAPIs = [finnhubKey && 'Finnhub', fmpKey && 'FMP', alphaVantageKey && 'AlphaV'].filter(Boolean);
            return { 
                price: null, 
                source: availableAPIs.length > 0 ? 'All APIs failed' : 'No API keys',
                tier: 0,
                success: false,
                error: availableAPIs.length > 0 ? 'Symbol not found in any API' : 'Configure API keys'
            };
        }
        
        // Try alternative ticker formats for international stocks
        async function tryAlternativeFormats(originalSymbol, assetName) {
            const alternatives = [];
            
            console.log(`\n=== TRYING ALTERNATIVES FOR ${originalSymbol} (${assetName}) ===`);
            
            // Strategy 1: Try common exchange suffixes
            if (originalSymbol.includes('.')) {
                // Has exchange suffix, try base symbol
                const base = originalSymbol.split('.')[0];
                alternatives.push(base);
                console.log(`Alternative: ${base} (removed exchange suffix)`);
            } else {
                // No suffix, try adding common ones
                alternatives.push(`${originalSymbol}.PA`); // Euronext Paris
                alternatives.push(`${originalSymbol}.L`);  // London Stock Exchange
                alternatives.push(`${originalSymbol}.DE`); // Frankfurt (XETRA)
                alternatives.push(`${originalSymbol}.MC`); // Madrid
                alternatives.push(`${originalSymbol}.SW`); // Switzerland (SIX)
                alternatives.push(`${originalSymbol}.AS`); // Amsterdam (Euronext)
                alternatives.push(`${originalSymbol}.MI`); // Milan
                alternatives.push(`${originalSymbol}.BR`); // Brussels
                alternatives.push(`${originalSymbol}.HE`); // Helsinki
                alternatives.push(`${originalSymbol}.ST`); // Stockholm
                alternatives.push(`${originalSymbol}.OL`); // Oslo
                alternatives.push(`${originalSymbol}.CO`); // Copenhagen
                console.log(`Alternatives: ${alternatives.join(', ')}`);
            }
            
            // Strategy 2: Smart ticker lookup based on asset name
            if (assetName && assetName !== originalSymbol) {
                // Common patterns for European stocks
                const nameLower = assetName.toLowerCase();
                
                // Extract company name (before "SA", "NV", "AG", etc.)
                let baseName = assetName.split(/\s+(SA|NV|AG|SE|PLC|INC|CORP|LTD|SPA|ASA|OYJ)/i)[0].trim();
                
                // Common ticker mappings (expanded)
                const smartMappings = {
                    'cellnex': ['CLNX', 'CLNX.MC'],
                    'covestro': ['1COV.DE', 'COV.DE'],
                    'prosus': ['PRX.AS', 'PROSUS'],
                    'adyen': ['ADYEN.AS', 'ADYEY'],
                    'just eat': ['JET.L', 'TKWY.AS'],
                    'moncler': ['MONC.MI', 'MONRF'],
                    'sartorius': ['SRT.DE', 'SRT3.DE'],
                    'nestle': ['NESN.SW', 'NSRGY'],
                    'roche': ['ROG.SW', 'RHHBY'],
                    'novartis': ['NOVN.SW', 'NVS'],
                    'asml': ['ASML.AS', 'ASML'],
                    'lvmh': ['MC.PA', 'LVMUY'],
                    'hermes': ['RMS.PA', 'HESAY'],
                    'schneider': ['SU.PA', 'SBGSF'],
                    'totalenergies': ['TTE.PA', 'TTE'],
                    'airbus': ['AIR.PA', 'EADSY']
                };
                
                // Check if asset name matches any known mapping
                for (const [key, tickers] of Object.entries(smartMappings)) {
                    if (nameLower.includes(key)) {
                        alternatives.push(...tickers);
                        console.log(`Smart mapping found for "${key}": ${tickers.join(', ')}`);
                        break;
                    }
                }
                
                // Try first word of company name as ticker
                const firstWord = baseName.split(' ')[0];
                if (firstWord.length >= 3 && firstWord.length <= 6) {
                    alternatives.push(firstWord.toUpperCase());
                    console.log(`Trying company name as ticker: ${firstWord.toUpperCase()}`);
                }
            }
            
            // Remove duplicates
            const uniqueAlternatives = [...new Set(alternatives)];
            console.log(`Total unique alternatives to try: ${uniqueAlternatives.length}`);
            
            // Try each alternative
            for (const altSymbol of uniqueAlternatives) {
                console.log(`Trying: ${altSymbol}...`);
                const result = await fetchStockPrice(altSymbol);
                if (result.success) {
                    console.log(`‚úì SUCCESS with ${altSymbol}!`);
                    return { ...result, alternativeSymbol: altSymbol, originalSymbol };
                }
                await new Promise(resolve => setTimeout(resolve, 500));
            }
            
            console.log(`‚úó All alternatives failed for ${originalSymbol}`);
            return null;
        }
        
        console.log('Variables initialized');

        
        function showApiKeyDialog() {
            document.getElementById('finnhubKeyInput').value = finnhubKey || '';
            document.getElementById('fmpKeyInput').value = fmpKey || '';
            document.getElementById('alphaVantageKeyInput').value = alphaVantageKey || '';
            document.getElementById('anthropicKeyInput').value = anthropicKey || '';
            document.getElementById('supabaseUrlInput').value = supabaseUrl || '';
            document.getElementById('supabaseAnonKeyInput').value = supabaseAnonKey || '';
            document.getElementById('apiKeyDialog').style.display = 'block';
        }
        
        function closeApiKeyDialog() {
            document.getElementById('apiKeyDialog').style.display = 'none';
        }
        
        function saveApiKeys() {
            const fhKey = document.getElementById('finnhubKeyInput').value.trim();
            const fmpKeyInput = document.getElementById('fmpKeyInput').value.trim();
            const avKey = document.getElementById('alphaVantageKeyInput').value.trim();
            const antKey = document.getElementById('anthropicKeyInput').value.trim();
            const sbUrl = document.getElementById('supabaseUrlInput').value.trim();
            const sbKey = document.getElementById('supabaseAnonKeyInput').value.trim();

            // Save to variables
            finnhubKey = fhKey;
            fmpKey = fmpKeyInput;
            alphaVantageKey = avKey;
            anthropicKey = antKey;
            supabaseUrl = sbUrl;
            supabaseAnonKey = sbKey;

            // Save to localStorage
            if (fhKey) {
                localStorage.setItem('finnhubKey', fhKey);
            } else {
                localStorage.removeItem('finnhubKey');
            }

            if (fmpKeyInput) {
                localStorage.setItem('fmpKey', fmpKeyInput);
            } else {
                localStorage.removeItem('fmpKey');
            }

            if (avKey) {
                localStorage.setItem('alphaVantageKey', avKey);
            } else {
                localStorage.removeItem('alphaVantageKey');
            }

            if (antKey) {
                localStorage.setItem('anthropicKey', antKey);
            } else {
                localStorage.removeItem('anthropicKey');
            }

            if (sbUrl) {
                localStorage.setItem('supabaseUrl', sbUrl);
            } else {
                localStorage.removeItem('supabaseUrl');
            }

            if (sbKey) {
                localStorage.setItem('supabaseAnonKey', sbKey);
            } else {
                localStorage.removeItem('supabaseAnonKey');
            }

            // Initialize Supabase if config provided
            if (sbUrl && sbKey) {
                initSupabase();
            } else {
                supabaseClient = null;
                currentUser = null;
                updateAuthBar();
            }

            let msg = '‚úì Settings saved!\n\n';

            if (fhKey || fmpKeyInput || avKey) {
                msg += 'Fetch Strategy:\n';
                if (fhKey) msg += '1Ô∏è‚É£ Finnhub (Primary - 60/min)\n';
                if (fmpKeyInput) msg += '2Ô∏è‚É£ FMP (Fallback - 250/day)\n';
                if (avKey) msg += '3Ô∏è‚É£ Alpha Vantage (Last resort - 5/min)\n';

                const totalSymbols = portfolio.length || 41;
                msg += '\n‚ö° Speed:\n';
                if (fhKey) {
                    msg += `~1 second per symbol = ~${Math.ceil(totalSymbols / 60)} min total\n`;
                } else if (fmpKeyInput) {
                    msg += `~1 second per symbol = ~${Math.ceil(totalSymbols / 60)} min total\n`;
                } else if (avKey) {
                    msg += `~12 seconds per symbol = ~${Math.ceil(totalSymbols * 12 / 60)} min total\n`;
                    msg += '\nüí° Add Finnhub or FMP for 12x faster!';
                }
            }

            if (sbUrl && sbKey) {
                msg += '\n‚òÅÔ∏è Cloud database configured! Use the auth bar to sign up or log in.';
            }

            alert(msg);
            closeApiKeyDialog();
        }
        
        function clearApiKeys() {
            if (confirm('‚ö†Ô∏è Clear all API keys and cloud settings?\n\nYou will need to re-enter them to fetch prices and sync.')) {
                finnhubKey = '';
                fmpKey = '';
                alphaVantageKey = '';
                anthropicKey = '';
                supabaseUrl = '';
                supabaseAnonKey = '';
                supabaseClient = null;
                currentUser = null;
                localStorage.removeItem('finnhubKey');
                localStorage.removeItem('fmpKey');
                localStorage.removeItem('alphaVantageKey');
                localStorage.removeItem('anthropicKey');
                localStorage.removeItem('supabaseUrl');
                localStorage.removeItem('supabaseAnonKey');
                document.getElementById('finnhubKeyInput').value = '';
                document.getElementById('fmpKeyInput').value = '';
                document.getElementById('alphaVantageKeyInput').value = '';
                document.getElementById('anthropicKeyInput').value = '';
                document.getElementById('supabaseUrlInput').value = '';
                document.getElementById('supabaseAnonKeyInput').value = '';
                updateAuthBar();
                alert('‚úì All keys and settings cleared.');
            }
        }

        // ========== SUPABASE INTEGRATION ==========

        function initSupabase() {
            if (!supabaseUrl || !supabaseAnonKey) {
                updateAuthBar();
                return false;
            }
            try {
                supabaseClient = supabase.createClient(supabaseUrl, supabaseAnonKey);

                supabaseClient.auth.onAuthStateChange((event, session) => {
                    currentUser = session?.user || null;
                    updateAuthBar();
                    if (event === 'SIGNED_IN') {
                        loadFromDatabase();
                    }
                });

                supabaseClient.auth.getSession().then(({ data: { session } }) => {
                    currentUser = session?.user || null;
                    updateAuthBar();
                    if (currentUser) {
                        loadFromDatabase();
                    }
                });

                console.log('‚úì Supabase initialized');
                return true;
            } catch (err) {
                console.error('Supabase init failed:', err);
                return false;
            }
        }

        function updateAuthBar() {
            const authBar = document.getElementById('authBar');
            if (!authBar) return;

            if (!supabaseClient) {
                authBar.style.display = 'none';
                return;
            }

            authBar.style.display = 'flex';

            if (currentUser) {
                authBar.innerHTML = `
                    <span style="color: #4ade80; font-weight: 600;">‚òÅÔ∏è Connected</span>
                    <span style="color: #94a3b8;">${escapeHTML(currentUser.email)}</span>
                    <span style="flex: 1;"></span>
                    <button class="btn-sm" style="background: #475569;" onclick="handleLogout()">Logout</button>
                `;
            } else {
                authBar.innerHTML = `
                    <span style="color: #94a3b8;">‚òÅÔ∏è Cloud Sync</span>
                    <input type="email" id="authEmail" placeholder="Email" />
                    <input type="password" id="authPassword" placeholder="Password" onkeydown="if(event.key==='Enter') handleLogin()" />
                    <button class="btn-sm" style="background: #2563eb;" onclick="handleLogin()">Login</button>
                    <button class="btn-sm" style="background: #7c3aed;" onclick="handleSignup()">Sign Up</button>
                `;
            }
        }

        async function handleLogin() {
            const email = document.getElementById('authEmail').value.trim();
            const password = document.getElementById('authPassword').value;

            if (!email || !password) {
                alert('Please enter email and password.');
                return;
            }

            try {
                const { data, error } = await supabaseClient.auth.signInWithPassword({ email, password });
                if (error) throw error;
                console.log('‚úì Logged in:', data.user.email);
            } catch (err) {
                alert('Login failed: ' + err.message);
            }
        }

        async function handleSignup() {
            const email = document.getElementById('authEmail').value.trim();
            const password = document.getElementById('authPassword').value;

            if (!email || !password) {
                alert('Please enter email and password.');
                return;
            }
            if (password.length < 6) {
                alert('Password must be at least 6 characters.');
                return;
            }

            try {
                const { data, error } = await supabaseClient.auth.signUp({ email, password });
                if (error) throw error;
                alert('Account created! Check your email to confirm your account, then log in.');
                console.log('‚úì Signed up:', data.user?.email);
            } catch (err) {
                alert('Sign up failed: ' + err.message);
            }
        }

        async function handleLogout() {
            try {
                await supabaseClient.auth.signOut();
                currentUser = null;
                updateAuthBar();
                console.log('‚úì Logged out');
            } catch (err) {
                console.error('Logout error:', err);
            }
        }

        async function loadFromDatabase() {
            if (!supabaseClient || !currentUser) return;

            try {
                console.log('‚òÅÔ∏è Loading data from Supabase...');

                // Load positions
                const { data: dbPositions, error: posError } = await supabaseClient
                    .from('positions')
                    .select('*')
                    .order('symbol');

                if (posError) throw posError;

                if (dbPositions && dbPositions.length > 0) {
                    portfolio = dbPositions.map(p => ({
                        name: p.name,
                        symbol: p.symbol,
                        platform: p.platform,
                        shares: Number(p.shares),
                        avgPrice: Number(p.avg_price)
                    }));
                    console.log('‚úì Loaded', portfolio.length, 'positions from DB');
                    renderPortfolio();
                } else if (portfolio.length > 0) {
                    // DB empty but local has data ‚Äî sync up
                    console.log('Syncing local portfolio to database...');
                    await savePortfolioDB();
                }

                // Load snapshots
                const { data: dbSnapshots, error: snapError } = await supabaseClient
                    .from('snapshots')
                    .select('*')
                    .order('timestamp', { ascending: true });

                if (snapError) throw snapError;

                if (dbSnapshots && dbSnapshots.length > 0) {
                    const existingTimestamps = new Set(portfolioHistory.map(s => s.timestamp));
                    dbSnapshots.forEach(s => {
                        const snap = {
                            timestamp: s.timestamp,
                            totalInvested: Number(s.total_invested),
                            totalMarketValue: Number(s.total_market_value),
                            positionCount: s.position_count,
                            pricesAvailable: s.prices_available
                        };
                        if (!existingTimestamps.has(snap.timestamp)) {
                            portfolioHistory.push(snap);
                        }
                    });
                    portfolioHistory.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                    localStorage.setItem('portfolioHistory', JSON.stringify(portfolioHistory));
                    console.log('‚úì Total snapshots after merge:', portfolioHistory.length);
                    updateHistoryDisplay();
                } else if (portfolioHistory.length > 0) {
                    // DB empty but local has snapshots ‚Äî sync up
                    console.log('Syncing local snapshots to database...');
                    for (const snapshot of portfolioHistory) {
                        await saveSnapshotToDB(snapshot);
                    }
                }

                // Load assets from DB into assetDatabase
                await loadAssetsFromDB();

                // Load cached prices from price_history (instant display before API fetch)
                await loadLatestPricesFromDB();
                if (Object.keys(marketPrices).length > 0) {
                    renderPortfolio();
                }

                // Load shared API keys from app_config
                await loadAppConfig();

            } catch (err) {
                console.error('Failed to load from database:', err);
            }
        }

        async function savePortfolioDB() {
            if (!supabaseClient || !currentUser) return;

            try {
                // Delete existing positions
                const { error: deleteError } = await supabaseClient
                    .from('positions')
                    .delete()
                    .eq('user_id', currentUser.id);

                if (deleteError) throw deleteError;

                // Insert new positions
                if (portfolio.length > 0) {
                    const rows = portfolio.map(p => ({
                        user_id: currentUser.id,
                        name: p.name,
                        symbol: p.symbol,
                        platform: p.platform,
                        shares: p.shares,
                        avg_price: p.avgPrice
                    }));

                    const { error: insertError } = await supabaseClient
                        .from('positions')
                        .insert(rows);

                    if (insertError) throw insertError;
                }

                console.log('‚úì Portfolio saved to Supabase');

                // Also save/update global assets and reload to get IDs
                const assetRecords = portfolio.map(p => buildAssetRecord(p));
                await saveAssetsToDB(assetRecords);
                await loadAssetsFromDB();
            } catch (err) {
                console.error('Failed to save portfolio to DB:', err);
            }
        }

        async function saveSnapshotToDB(snapshot) {
            if (!supabaseClient || !currentUser) return;

            try {
                const { error } = await supabaseClient
                    .from('snapshots')
                    .insert({
                        user_id: currentUser.id,
                        timestamp: snapshot.timestamp,
                        total_invested: snapshot.totalInvested,
                        total_market_value: snapshot.totalMarketValue,
                        position_count: snapshot.positionCount,
                        prices_available: snapshot.pricesAvailable
                    });

                if (error) throw error;
                console.log('‚úì Snapshot saved to Supabase');
            } catch (err) {
                console.error('Failed to save snapshot to DB:', err);
            }
        }

        async function clearHistoryFromDB() {
            if (!supabaseClient || !currentUser) return;

            try {
                const { error } = await supabaseClient
                    .from('snapshots')
                    .delete()
                    .eq('user_id', currentUser.id);

                if (error) throw error;
                console.log('‚úì History cleared from Supabase');
            } catch (err) {
                console.error('Failed to clear history from DB:', err);
            }
        }

        async function loadAppConfig() {
            if (!supabaseClient || !currentUser) return;

            try {
                const { data, error } = await supabaseClient
                    .from('app_config')
                    .select('key, value');

                if (error) throw error;

                if (data && data.length > 0) {
                    data.forEach(row => {
                        if (row.key === 'finnhubKey' && row.value) finnhubKey = row.value;
                        if (row.key === 'fmpKey' && row.value) fmpKey = row.value;
                        if (row.key === 'alphaVantageKey' && row.value) alphaVantageKey = row.value;
                    });
                    console.log('‚úì API keys loaded from DB:', {
                        finnhub: !!finnhubKey,
                        fmp: !!fmpKey,
                        alphaVantage: !!alphaVantageKey
                    });
                }
            } catch (err) {
                console.warn('Failed to load app config from DB:', err);
            }
        }

        // ========== ASSETS & PRICE HISTORY DB ==========

        // Determine stock exchange from ticker suffix
        function detectStockExchange(ticker) {
            if (!ticker) return 'Unknown';
            if (ticker.includes('.PA')) return 'Euronext Paris';
            if (ticker.includes('.L')) return 'London (LSE)';
            if (ticker.includes('.DE')) return 'Frankfurt (XETRA)';
            if (ticker.includes('.AS')) return 'Euronext Amsterdam';
            if (ticker.includes('.MI')) return 'Milan (Borsa)';
            if (ticker.includes('.SW')) return 'Swiss (SIX)';
            if (ticker.includes('.MC')) return 'Madrid';
            if (ticker.includes('.BR')) return 'Brussels';
            if (ticker.includes('.HE')) return 'Helsinki';
            if (ticker.includes('.ST')) return 'Stockholm';
            if (ticker.includes('.OL')) return 'Oslo';
            if (ticker.includes('.CO')) return 'Copenhagen';
            if (ticker.includes('.TO')) return 'Toronto (TSX)';
            if (ticker.includes('.HK')) return 'Hong Kong';
            if (ticker.includes('.T')) return 'Tokyo';
            return 'US'; // Default for tickers without suffix
        }

        // Determine currency from stock exchange
        function detectCurrency(stockExchange) {
            const currencyMap = {
                'US': 'USD',
                'Euronext Paris': 'EUR',
                'Frankfurt (XETRA)': 'EUR',
                'Euronext Amsterdam': 'EUR',
                'Milan (Borsa)': 'EUR',
                'Madrid': 'EUR',
                'Brussels': 'EUR',
                'Helsinki': 'EUR',
                'London (LSE)': 'GBP',
                'Swiss (SIX)': 'CHF',
                'Stockholm': 'SEK',
                'Oslo': 'NOK',
                'Copenhagen': 'DKK',
                'Toronto (TSX)': 'CAD',
                'Hong Kong': 'HKD',
                'Tokyo': 'JPY'
            };
            return currencyMap[stockExchange] || 'USD';
        }

        // Build an asset record from a portfolio position
        function buildAssetRecord(position) {
            const ticker = position.symbol.toUpperCase();
            const stockExchange = detectStockExchange(ticker);
            const currency = detectCurrency(stockExchange);
            const sector = getSector(ticker);
            return {
                ticker: ticker,
                name: position.name || ticker,
                stock_exchange: stockExchange,
                sector: sector,
                currency: currency,
                asset_type: position.type || 'Stock'
            };
        }

        // Save/upsert assets to Supabase (global ‚Äî shared across all users)
        async function saveAssetsToDB(assets) {
            if (!supabaseClient) return;

            try {
                for (const asset of assets) {
                    const { error } = await supabaseClient
                        .from('assets')
                        .upsert({
                            ticker: asset.ticker,
                            name: asset.name,
                            stock_exchange: asset.stock_exchange,
                            sector: asset.sector,
                            currency: asset.currency,
                            asset_type: asset.asset_type,
                            updated_at: new Date().toISOString()
                        }, { onConflict: 'ticker' });

                    if (error) {
                        console.warn(`Failed to upsert asset ${asset.ticker}:`, error.message);
                    }
                }
                console.log('‚úì Saved', assets.length, 'assets to DB');
            } catch (err) {
                console.error('Failed to save assets to DB:', err);
            }
        }

        // Load all assets from Supabase (global catalog)
        async function loadAssetsFromDB() {
            if (!supabaseClient) return;

            try {
                const { data, error } = await supabaseClient
                    .from('assets')
                    .select('*')
                    .order('ticker');

                if (error) {
                    console.warn('Failed to load assets from DB:', error.message);
                    return;
                }

                if (data && data.length > 0) {
                    data.forEach(a => {
                        assetDatabase[a.ticker.toUpperCase()] = {
                            id: a.id,
                            name: a.name,
                            ticker: a.ticker,
                            stockExchange: a.stock_exchange,
                            sector: a.sector,
                            currency: a.currency,
                            assetType: a.asset_type
                        };
                    });
                    console.log('‚úì Loaded', data.length, 'assets from DB into assetDatabase');
                }
            } catch (err) {
                console.error('Failed to load assets from DB:', err);
            }
        }

        // Save a batch of prices to price_history (global ‚Äî linked to asset_id)
        async function savePriceHistoryToDB(priceRecords) {
            if (!supabaseClient) return;

            try {
                const rows = [];
                for (const r of priceRecords) {
                    const asset = assetDatabase[r.ticker.toUpperCase()];
                    if (!asset || !asset.id) {
                        console.warn(`Skipping price for ${r.ticker}: no asset_id in DB`);
                        continue;
                    }
                    rows.push({
                        asset_id: asset.id,
                        price: r.price,
                        currency: r.currency || 'USD',
                        source: r.source,
                        fetched_at: r.fetchedAt || new Date().toISOString()
                    });
                }

                if (rows.length === 0) return;

                const { error } = await supabaseClient
                    .from('price_history')
                    .insert(rows);

                if (error) {
                    console.warn('Failed to save price history:', error.message);
                } else {
                    console.log('‚úì Saved', rows.length, 'price records to history');
                }
            } catch (err) {
                console.error('Failed to save price history to DB:', err);
            }
        }

        // Load the most recent price for each ticker from price_history (global)
        async function loadLatestPricesFromDB() {
            if (!supabaseClient) return;

            try {
                // Get unique tickers from portfolio
                const tickers = [...new Set(portfolio.map(p => p.symbol.toUpperCase()))];
                if (tickers.length === 0) return;

                // Collect asset_ids for portfolio tickers
                const assetIds = tickers
                    .map(t => assetDatabase[t]?.id)
                    .filter(Boolean);
                if (assetIds.length === 0) return;

                const { data, error } = await supabaseClient
                    .from('price_history')
                    .select('asset_id, price, currency, source, fetched_at')
                    .in('asset_id', assetIds)
                    .order('fetched_at', { ascending: false });

                if (error) {
                    console.warn('Failed to load latest prices from DB:', error.message);
                    return;
                }

                if (data && data.length > 0) {
                    // Build reverse lookup: asset_id -> ticker
                    const idToTicker = {};
                    for (const [ticker, info] of Object.entries(assetDatabase)) {
                        if (info.id) idToTicker[info.id] = ticker;
                    }

                    const seen = new Set();
                    let loadedCount = 0;
                    data.forEach(row => {
                        if (!seen.has(row.asset_id)) {
                            seen.add(row.asset_id);
                            const ticker = idToTicker[row.asset_id];
                            if (ticker) {
                                marketPrices[ticker] = Number(row.price);
                                priceMetadata[ticker] = {
                                    timestamp: row.fetched_at,
                                    source: row.source + ' (cached)',
                                    success: true
                                };
                                loadedCount++;
                            }
                        }
                    });
                    console.log('‚úì Loaded', loadedCount, 'cached prices from DB');
                }
            } catch (err) {
                console.error('Failed to load latest prices from DB:', err);
            }
        }

        // Load price history for a specific asset (for charts/analysis)
        async function loadPriceHistoryForAsset(ticker, limit = 30) {
            if (!supabaseClient) return [];

            try {
                const asset = assetDatabase[ticker.toUpperCase()];
                if (!asset || !asset.id) return [];

                const { data, error } = await supabaseClient
                    .from('price_history')
                    .select('price, currency, source, fetched_at')
                    .eq('asset_id', asset.id)
                    .order('fetched_at', { ascending: false })
                    .limit(limit);

                if (error) {
                    console.warn(`Failed to load price history for ${ticker}:`, error.message);
                    return [];
                }

                return (data || []).reverse(); // Return in chronological order
            } catch (err) {
                console.error(`Failed to load price history for ${ticker}:`, err);
                return [];
            }
        }

        // ========== END SUPABASE INTEGRATION ==========

        function escapeHTML(str) {
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }

        function formatCurrency(num) {
            return '$' + num.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
        }

        function formatPercent(num) {
            const sign = num >= 0 ? '+' : '';
            return sign + num.toFixed(2) + '%';
        }

        async function savePortfolioSnapshot() {
            if (portfolio.length === 0) {
                alert('‚ùå No portfolio to save. Import your portfolio first.');
                return;
            }
            
            let totalInvested = 0;
            let totalMarketValue = 0;
            
            portfolio.forEach(p => {
                const invested = p.shares * p.avgPrice;
                totalInvested += invested;
                
                const currentPrice = marketPrices[p.symbol];
                if (currentPrice) {
                    totalMarketValue += p.shares * currentPrice;
                } else {
                    totalMarketValue += invested;
                }
            });
            
            const snapshot = {
                timestamp: new Date().toISOString(),
                totalInvested: totalInvested,
                totalMarketValue: totalMarketValue,
                positionCount: portfolio.length,
                pricesAvailable: Object.keys(marketPrices).length
            };
            
            portfolioHistory.push(snapshot);
            
            // Save to localStorage (always as fallback)
            localStorage.setItem('portfolioHistory', JSON.stringify(portfolioHistory));
            
            let cloudSaved = false;
            let dbSaved = false;

            // Save to Supabase (if connected)
            try {
                await saveSnapshotToDB(snapshot);
                if (supabaseClient && currentUser) dbSaved = true;
            } catch (err) {
                console.warn('Supabase save failed:', err);
            }

            // Save to Claude cloud storage (if available)
            if (typeof window.storage !== 'undefined') {
                try {
                    // Save individual snapshot with timestamp as key
                    const snapshotKey = `snapshot:${Date.now()}`;
                    await window.storage.set(snapshotKey, JSON.stringify(snapshot), false);
                    console.log('‚úì Snapshot saved to cloud:', snapshotKey);

                    // Save current portfolio state
                    await window.storage.set('current-portfolio', JSON.stringify({
                        portfolio: portfolio,
                        marketPrices: marketPrices,
                        priceMetadata: priceMetadata,
                        lastUpdated: new Date().toISOString()
                    }), false);
                    console.log('‚úì Portfolio saved to cloud');

                    cloudSaved = true;
                } catch (err) {
                    console.warn('Cloud storage failed, saved locally only:', err);
                }
            }

            console.log('Portfolio snapshot saved:', snapshot);
            updateHistoryDisplay();

            const gainLoss = totalMarketValue - totalInvested;
            const gainLossPct = totalInvested > 0 ? (gainLoss / totalInvested) * 100 : 0;
            const syncStatus = dbSaved ? '‚òÅÔ∏è Synced to Supabase' : cloudSaved ? '‚òÅÔ∏è Synced to cloud storage' : 'üíæ Saved to browser only';
            alert(`‚úì Portfolio snapshot saved!\n\nInvested: ${formatCurrency(totalInvested)}\nMarket Value: ${formatCurrency(totalMarketValue)}\nGain/Loss: ${formatCurrency(gainLoss)} (${formatPercent(gainLossPct)})\n\nTotal snapshots: ${portfolioHistory.length}\n\n${syncStatus}`);
        }

        function updateHistoryDisplay() {
            try {
                if (portfolioHistory.length === 0) {
                    document.getElementById('historySection').style.display = 'none';
                    return;
                }
                
                console.log('Updating history display with', portfolioHistory.length, 'snapshots');
                
                document.getElementById('historySection').style.display = 'block';
                
                // Update chart
                updateChart();
                
                // Update log
                const historyLog = document.getElementById('historyLog');
                if (!historyLog) {
                    console.error('History log element not found');
                    return;
                }
                
                historyLog.innerHTML = `
                    <h3 style="margin-bottom: 10px; color: #cbd5e1;">Snapshot Log</h3>
                    <div style="max-height: 300px; overflow-y: auto;">
                        ${portfolioHistory.slice().reverse().map((snapshot, idx) => {
                            const date = new Date(snapshot.timestamp);
                            const gainLoss = snapshot.totalMarketValue - snapshot.totalInvested;
                            const gainLossPct = snapshot.totalInvested > 0 ? (gainLoss / snapshot.totalInvested) * 100 : 0;
                            const color = gainLoss >= 0 ? '#4ade80' : '#f87171';
                            
                            return `
                                <div style="background: #334155; padding: 12px; border-radius: 8px; margin-bottom: 8px; border-left: 3px solid ${color};">
                                    <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 5px;">
                                        <div style="font-size: 13px; color: #94a3b8;">
                                            ${date.toLocaleDateString()} ${date.toLocaleTimeString()}
                                        </div>
                                        <div style="font-size: 12px; color: #94a3b8;">
                                            ${snapshot.positionCount} positions ‚Ä¢ ${snapshot.pricesAvailable} with prices
                                        </div>
                                    </div>
                                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; font-size: 13px;">
                                        <div>
                                            <div style="color: #94a3b8; font-size: 11px;">Invested</div>
                                            <div style="color: #cbd5e1;">${formatCurrency(snapshot.totalInvested)}</div>
                                        </div>
                                        <div>
                                            <div style="color: #94a3b8; font-size: 11px;">Market Value</div>
                                            <div style="color: #cbd5e1;">${formatCurrency(snapshot.totalMarketValue)}</div>
                                        </div>
                                        <div>
                                            <div style="color: #94a3b8; font-size: 11px;">Gain/Loss</div>
                                            <div style="color: ${color}; font-weight: bold;">${formatCurrency(gainLoss)} (${formatPercent(gainLossPct)})</div>
                                        </div>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                    <button class="btn btn-add" onclick="clearHistory()" style="margin-top: 15px; background: #dc2626;">üóëÔ∏è Clear History</button>
                `;
                
                console.log('History display updated successfully');
            } catch (err) {
                console.error('Error updating history display:', err);
                console.error('Error stack:', err.stack);
            }
        }

        function updateChart() {
            if (portfolioHistory.length === 0) return;
            
            try {
                const chartDiv = document.getElementById('historyChart');
                if (!chartDiv) {
                    console.error('Chart div not found');
                    return;
                }
                
                console.log('Creating CSS-based chart');
                
                // Find min and max values for scaling
                const allValues = portfolioHistory.flatMap(s => [s.totalInvested, s.totalMarketValue]);
                const minValue = Math.min(...allValues) * 0.95;
                const maxValue = Math.max(...allValues) * 1.05;
                const range = maxValue - minValue;
                
                // Create simple bar chart
                let chartHTML = '<div style="background: #334155; padding: 20px; border-radius: 10px;">';
                chartHTML += '<div style="display: flex; justify-content: space-around; gap: 8px; align-items: flex-end; height: 200px;">';
                
                portfolioHistory.forEach((snapshot, idx) => {
                    const date = new Date(snapshot.timestamp);
                    const label = `${date.getMonth()+1}/${date.getDate()}`;
                    const marketHeight = ((snapshot.totalMarketValue - minValue) / range) * 180;
                    const investedHeight = ((snapshot.totalInvested - minValue) / range) * 180;
                    const gainLoss = snapshot.totalMarketValue - snapshot.totalInvested;
                    const color = gainLoss >= 0 ? '#4ade80' : '#f87171';
                    
                    chartHTML += `
                        <div style="flex: 1; display: flex; flex-direction: column; align-items: center; min-width: 40px;">
                            <div style="position: relative; width: 100%; height: 180px; display: flex; align-items: flex-end; justify-content: center; gap: 2px;">
                                <div style="width: 45%; background: #60a5fa; height: ${investedHeight}px; border-radius: 3px 3px 0 0; position: relative;" title="Invested: ${formatCurrency(snapshot.totalInvested)}"></div>
                                <div style="width: 45%; background: ${color}; height: ${marketHeight}px; border-radius: 3px 3px 0 0; position: relative;" title="Market: ${formatCurrency(snapshot.totalMarketValue)}"></div>
                            </div>
                            <div style="font-size: 10px; color: #94a3b8; margin-top: 5px; text-align: center;">${label}</div>
                        </div>
                    `;
                });
                
                chartHTML += '</div>';
                
                // Legend
                chartHTML += `
                    <div style="display: flex; justify-content: center; gap: 20px; margin-top: 15px; font-size: 12px;">
                        <div style="display: flex; align-items: center; gap: 5px;">
                            <div style="width: 12px; height: 12px; background: #60a5fa; border-radius: 2px;"></div>
                            <span style="color: #cbd5e1;">Invested</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 5px;">
                            <div style="width: 12px; height: 12px; background: #4ade80; border-radius: 2px;"></div>
                            <span style="color: #cbd5e1;">Market Value (Profit)</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 5px;">
                            <div style="width: 12px; height: 12px; background: #f87171; border-radius: 2px;"></div>
                            <span style="color: #cbd5e1;">Market Value (Loss)</span>
                        </div>
                    </div>
                `;
                
                chartHTML += '</div>';
                
                chartDiv.innerHTML = chartHTML;
                console.log('Chart created successfully');
            } catch (err) {
                console.error('Error creating chart:', err);
                console.error('Error stack:', err.stack);
            }
        }

        function clearHistory() {
            if (confirm('Are you sure you want to clear all portfolio history?\n\nThis cannot be undone.')) {
                portfolioHistory = [];
                localStorage.removeItem('portfolioHistory');
                clearHistoryFromDB();
                document.getElementById('historySection').style.display = 'none';
                alert('‚úì History cleared');
            }
        }

        async function fetchMarketPrices() {
            if (portfolio.length === 0) {
                alert('‚ùå No positions in portfolio. Import your portfolio first.');
                return;
            }
            
            // Check if user has any API keys configured
            if (!alphaVantageKey && !finnhubKey && !fmpKey) {
                alert(
                    'üîë API Keys Required\n\n' +
                    'Click the "üîë API Keys" button to configure your API keys.\n\n' +
                    'You need at least one free API key to fetch live prices.'
                );
                return;
            }
            
            const refreshBtn = document.getElementById('refreshBtn');
            const originalText = refreshBtn.textContent;
            refreshBtn.disabled = true;
            refreshBtn.textContent = '‚è≥ Fetching...';
            
            pricesLoading = true;
            const symbols = [...new Set(portfolio.map(p => p.symbol))]; // Get unique symbols
            
            // Determine rate limiting based on available APIs
            let delayBetweenCalls = 1000; // Default 1s
            let apiInfo = '';

            if (finnhubKey) {
                delayBetweenCalls = 1000; // 1 second (60/min for Finnhub primary)
                apiInfo = 'Using Finnhub (primary)';
                if (fmpKey) apiInfo += ' + FMP (fallback #1)';
                if (alphaVantageKey) apiInfo += ' + Alpha Vantage (fallback #2)';
            } else if (fmpKey) {
                delayBetweenCalls = 500; // FMP has no per-minute limit, 250/day
                apiInfo = 'Using FMP (primary - 250/day)';
                if (alphaVantageKey) apiInfo += ' + Alpha Vantage (fallback)';
            } else if (alphaVantageKey) {
                delayBetweenCalls = 12000; // 12 seconds (5/min limit)
                apiInfo = 'Using Alpha Vantage only (5 calls/min - slower)';
            }
            
            console.log('=== FETCH PRICES ===');
            console.log('API Configuration:', apiInfo);
            console.log('Symbols:', symbols);
            console.log('Total:', symbols.length);
            console.log('Delay between calls:', delayBetweenCalls + 'ms');
            
            // Estimate time
            const estimatedSeconds = Math.ceil((symbols.length * delayBetweenCalls) / 1000);
            const estimatedMinutes = Math.floor(estimatedSeconds / 60);
            const remainingSeconds = estimatedSeconds % 60;
            const timeEstimate = estimatedMinutes > 0 
                ? `~${estimatedMinutes}m ${remainingSeconds}s` 
                : `~${estimatedSeconds}s`;
            
            console.log('Estimated time:', timeEstimate);
            
            if (estimatedMinutes > 2) {
                const proceed = confirm(
                    `‚è±Ô∏è Estimated fetch time: ${timeEstimate}\n\n` +
                    `Fetching ${symbols.length} symbols with current API configuration.\n\n` +
                    `Tip: Add Finnhub API for faster updates (60 calls/min)\n\n` +
                    `Continue?`
                );
                
                if (!proceed) {
                    refreshBtn.disabled = false;
                    refreshBtn.textContent = originalText;
                    pricesLoading = false;
                    return;
                }
            }
            
            let successCount = 0;
            let failCount = 0;
            const errors = [];
            
            try {
                // Fetch all symbols using the new multi-source function
                for (let i = 0; i < symbols.length; i++) {
                    const symbol = symbols[i];
                    
                    refreshBtn.textContent = `‚è≥ ${i + 1}/${symbols.length}`;
                    
                    try {
                        // Try primary sources first
                        let result = await fetchStockPrice(symbol);
                        
                        // If failed, try alternative ticker formats
                        if (!result.success) {
                            console.log(`Primary failed for ${symbol}, trying alternatives...`);
                            const position = portfolio.find(p => p.symbol === symbol);
                            const assetName = position ? position.name : symbol;
                            const altResult = await tryAlternativeFormats(symbol, assetName);
                            if (altResult && altResult.success) {
                                result = altResult;
                                console.log(`‚úì Found ${symbol} as ${altResult.alternativeSymbol}`);
                            }
                        }
                        
                        // Store result
                        if (result.success) {
                            marketPrices[symbol] = result.price;
                            priceMetadata[symbol] = {
                                timestamp: new Date().toISOString(),
                                source: result.source + (result.alternativeSymbol ? ` (as ${result.alternativeSymbol})` : ''),
                                success: true
                            };
                            successCount++;
                        } else {
                            priceMetadata[symbol] = {
                                timestamp: new Date().toISOString(),
                                source: result.source,
                                success: false,
                                error: result.error
                            };
                            errors.push(`${symbol}: ${result.error}`);
                            failCount++;
                        }
                        
                        // Update display every 5 symbols
                        if ((i + 1) % 5 === 0 || i === symbols.length - 1) {
                            renderPortfolio();
                        }
                        
                        // Small delay to respect rate limits
                        await new Promise(resolve => setTimeout(resolve, delayBetweenCalls));
                        
                    } catch (err) {
                        console.error(`‚úó ${symbol}: ${err.message}`);
                        priceMetadata[symbol] = {
                            timestamp: new Date().toISOString(),
                            source: 'Error',
                            success: false,
                            error: err.message
                        };
                        errors.push(`${symbol}: ${err.message}`);
                        failCount++;
                    }
                }
                
                console.log('\n=== FETCH COMPLETE ===');
                console.log('Success:', successCount);
                console.log('Failed:', failCount);
                
                renderPortfolio();

                // Save freshly fetched prices to price_history DB (skip cached ones from DB load)
                if (successCount > 0) {
                    const priceRecords = [];
                    const now = new Date().toISOString();
                    for (const [symbol, price] of Object.entries(marketPrices)) {
                        const meta = priceMetadata[symbol];
                        if (meta && meta.success && !meta.source.includes('(cached)')) {
                            const assetInfo = assetDatabase[symbol.toUpperCase()];
                            priceRecords.push({
                                ticker: symbol.toUpperCase(),
                                price: price,
                                currency: assetInfo ? assetInfo.currency : 'USD',
                                source: meta.source,
                                fetchedAt: now
                            });
                        }
                    }
                    if (priceRecords.length > 0) {
                        await savePriceHistoryToDB(priceRecords);
                    }
                }

                let msg = `‚úì Price update complete!\n\n`;
                msg += `‚úì Successfully fetched: ${successCount} symbols\n`;
                if (failCount > 0) {
                    msg += `‚úó Failed: ${failCount} symbols\n\n`;
                    msg += `Failed symbols:\n`;
                    errors.forEach(err => {
                        msg += `‚Ä¢ ${err}\n`;
                    });
                }

                // Auto-save snapshot after price update
                if (successCount > 0) {
                    await savePortfolioSnapshot();
                    msg += '\n\nüìä Portfolio snapshot saved to history!';
                }
                
                alert(msg);
                
            } catch (err) {
                console.error('=== FETCH PRICES ERROR ===');
                console.error('Error:', err);
                alert(`‚ùå Error fetching prices: ${err.message}\n\nCheck console (F12) for details.`);
            } finally {
                pricesLoading = false;
                refreshBtn.disabled = false;
                refreshBtn.textContent = originalText;
            }
        }

        function renderPortfolio() {
            const positionsDiv = document.getElementById('positions');
            
            let totalInvested = 0;
            let totalMarketValue = 0;
            let positionsWithPrices = 0;
            
            portfolio.forEach(p => {
                const invested = p.shares * p.avgPrice;
                totalInvested += invested;
                
                const currentPrice = marketPrices[p.symbol];
                if (currentPrice) {
                    totalMarketValue += p.shares * currentPrice;
                    positionsWithPrices++;
                } else {
                    totalMarketValue += invested; // Use cost basis if no market price
                }
            });
            
            console.log('=== RENDER PORTFOLIO DEBUG ===');
            console.log('Rendering portfolio:', portfolio.length, 'positions');
            console.log('Positions with live prices:', positionsWithPrices);
            console.log('Market prices available:', Object.keys(marketPrices));
            console.log('Total invested:', totalInvested);
            console.log('Total market value:', totalMarketValue);
            console.log('Using cost basis for', portfolio.length - positionsWithPrices, 'positions without prices');
            
            // Update header with invested vs market value
            const portfolioHeader = document.querySelector('.portfolio-header');
            const totalGainLoss = totalMarketValue - totalInvested;
            const totalGainLossPct = totalInvested > 0 ? (totalGainLoss / totalInvested) * 100 : 0;
            const gainLossColor = totalGainLoss >= 0 ? '#4ade80' : '#f87171';
            
            portfolioHeader.innerHTML = `
                <div>
                    <h2 style="margin-bottom: 5px;">üíº Your Portfolio</h2>
                    <div style="font-size: 13px; color: #94a3b8;">
                        ${portfolio.length} position${portfolio.length !== 1 ? 's' : ''}
                        ${Object.keys(marketPrices).length > 0 ? ` ‚Ä¢ ${positionsWithPrices} with live prices` : ' ‚Ä¢ Click "Update Prices" for live market data'}
                    </div>
                </div>
                <div class="total-value">
                    <div style="color: #94a3b8; font-size: 12px;">Total Invested</div>
                    <div style="color: #cbd5e1; font-size: 16px; margin-bottom: 5px;">${formatCurrency(totalInvested)}</div>
                    <div style="color: #94a3b8; font-size: 12px;">Market Value</div>
                    <div style="color: ${gainLossColor}; font-size: 24px; font-weight: bold;">${formatCurrency(totalMarketValue)}</div>
                    ${totalInvested > 0 ? `
                        <div style="color: ${gainLossColor}; font-size: 14px; margin-top: 5px;">
                            ${formatCurrency(totalGainLoss)} (${formatPercent(totalGainLossPct)})
                        </div>
                    ` : ''}
                </div>
            `;
            
            if (portfolio.length === 0) {
                positionsDiv.innerHTML = '<div style="text-align: center; color: #64748b; padding: 40px;">No positions yet. Import your portfolio from spreadsheet to get started.</div>';
                return;
            }
            
            // Add header row
            let html = `
                <div class="position-header-row">
                    <div>Symbol</div>
                    <div>Asset Name / Platform</div>
                    <div>Sector</div>
                    <div>Shares</div>
                    <div>Avg Price</div>
                    <div>Current Price</div>
                    <div>Invested</div>
                    <div>Market Value</div>
                    <div>Weight</div>
                    <div>Gain/Loss</div>
                </div>
            `;
            
            html += portfolio.map((pos, idx) => {
                const invested = pos.shares * pos.avgPrice;
                const currentPrice = marketPrices[pos.symbol];
                const hasPrice = currentPrice !== undefined;
                const marketValue = hasPrice ? pos.shares * currentPrice : invested;
                const gainLoss = marketValue - invested;
                const gainLossPct = invested > 0 ? (gainLoss / invested) * 100 : 0;
                const weight = totalMarketValue > 0 ? (marketValue / totalMarketValue) * 100 : 0;
                const color = gainLoss >= 0 ? '#4ade80' : '#f87171';
                
                // Get price metadata
                const metadata = priceMetadata[pos.symbol];
                let statusFlag = '‚è≥';
                let statusColor = '#f59e0b';
                let statusText = 'Pending';
                let timestampText = '';
                
                if (metadata) {
                    if (metadata.success) {
                        statusFlag = '‚úì';
                        statusColor = '#4ade80';
                        statusText = metadata.source;
                        
                        // Format timestamp
                        const date = new Date(metadata.timestamp);
                        const now = new Date();
                        const diffMs = now - date;
                        const diffMins = Math.floor(diffMs / 60000);
                        
                        if (diffMins < 1) {
                            timestampText = 'Just now';
                        } else if (diffMins < 60) {
                            timestampText = `${diffMins}m ago`;
                        } else {
                            const diffHours = Math.floor(diffMins / 60);
                            if (diffHours < 24) {
                                timestampText = `${diffHours}h ago`;
                            } else {
                                timestampText = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                            }
                        }
                    } else {
                        statusFlag = '‚úó';
                        statusColor = '#f87171';
                        statusText = metadata.error || 'Failed';
                        timestampText = 'Failed to fetch';
                    }
                }
                
                return `
                <div class="position">
                    <div class="position-symbol">
                        <div style="display: flex; align-items: center; gap: 5px;">
                            <span style="color: ${statusColor}; font-size: 14px;" title="${escapeHTML(statusText)}">${statusFlag}</span>
                            <span>${escapeHTML(pos.symbol)}</span>
                        </div>
                        ${timestampText ? `<div style="font-size: 9px; color: #64748b; margin-top: 2px;">${escapeHTML(timestampText)}</div>` : ''}
                    </div>
                    <div class="position-details" style="font-size: 12px; color: #94a3b8;" title="${escapeHTML(pos.name || pos.symbol)}${pos.platform ? '\nPlatform: ' + escapeHTML(pos.platform) : ''}">
                        ${pos.name ? escapeHTML(pos.name.length > 30 ? pos.name.substring(0, 27) + '...' : pos.name) : escapeHTML(pos.symbol)}
                        ${pos.platform && pos.platform !== 'Unknown' ? `<div style="font-size: 9px; color: #64748b; margin-top: 2px;">üìç ${escapeHTML(pos.platform)}</div>` : ''}
                    </div>
                    <div class="position-details" style="font-size: 11px; color: #94a3b8;" title="${escapeHTML(getSector(pos.symbol))}${assetDatabase[pos.symbol.toUpperCase()] ? '\nExchange: ' + escapeHTML(assetDatabase[pos.symbol.toUpperCase()].stockExchange || '') + '\nCurrency: ' + escapeHTML(assetDatabase[pos.symbol.toUpperCase()].currency || '') : ''}">
                        ${escapeHTML(getSector(pos.symbol))}
                        ${assetDatabase[pos.symbol.toUpperCase()] && assetDatabase[pos.symbol.toUpperCase()].currency && assetDatabase[pos.symbol.toUpperCase()].currency !== 'USD' ? `<div style="font-size: 9px; color: #64748b; margin-top: 2px;">${escapeHTML(assetDatabase[pos.symbol.toUpperCase()].currency)}</div>` : ''}
                    </div>
                    <div class="position-details">${pos.shares}</div>
                    <div class="position-details">${formatCurrency(pos.avgPrice)}</div>
                    <div class="position-details" style="color: ${hasPrice ? '#60a5fa' : '#f59e0b'};">
                        ${hasPrice ? formatCurrency(currentPrice) : '‚è≥ Pending'}
                    </div>
                    <div class="position-details">${formatCurrency(invested)}</div>
                    <div class="position-value" style="color: ${color};">
                        ${formatCurrency(marketValue)}
                    </div>
                    <div class="position-details" style="font-weight: 600;">
                        ${weight.toFixed(1)}%
                    </div>
                    <div style="color: ${color}; font-weight: bold;">
                        ${gainLoss >= 0 ? '+' : ''}${formatCurrency(gainLoss)}
                        <span style="font-size: 11px; margin-left: 4px;">(${formatPercent(gainLossPct)})</span>
                    </div>
                </div>
            `;
            }).join('');
            
            positionsDiv.innerHTML = html;

            // Render allocation charts
            renderAllocationCharts();

            console.log('Portfolio rendered successfully');
        }

        console.log('=== DEFINING showImportDialog FUNCTION ===');

        function showImportDialog() {
            try {
                console.log('=== IMPORT DIALOG OPENED ===');
                const dialog = document.getElementById('importDialog');
                const textarea = document.getElementById('importText');
                
                if (!dialog) {
                    throw new Error('Import dialog element not found');
                }
                if (!textarea) {
                    throw new Error('Import textarea element not found');
                }
                
                dialog.style.display = 'block';
                textarea.focus();
                console.log('Import dialog displayed successfully');
            } catch (err) {
                console.error('=== SHOW IMPORT DIALOG ERROR ===');
                console.error('Error:', err.message);
                console.error('Stack:', err.stack);
                alert('Error opening import dialog: ' + err.message + '\n\nPlease refresh the page and try again.');
            }
        }

        function closeImportDialog() {
            try {
                console.log('=== IMPORT DIALOG CLOSED ===');
                const dialog = document.getElementById('importDialog');
                const textarea = document.getElementById('importText');
                
                if (dialog) {
                    dialog.style.display = 'none';
                }
                if (textarea) {
                    textarea.value = '';
                }
                console.log('Import dialog closed, current portfolio:', portfolio.length, 'positions');
            } catch (err) {
                console.error('=== CLOSE IMPORT DIALOG ERROR ===');
                console.error('Error:', err.message);
                console.error('Stack:', err.stack);
            }
        }

        function importPositions() {
            console.log('=== IMPORT POSITIONS STARTED ===');
            
            const text = document.getElementById('importText').value.trim();
            if (!text) {
                console.error('No text provided for import');
                alert('Please paste your positions data');
                return;
            }

            console.log('Import text length:', text.length, 'characters');

            const lines = text.split('\n');
            const newPositions = [];
            const errors = [];
            const debugInfo = [];
            let isFirstLine = true;

            console.log('=== IMPORT DEBUG ===');
            console.log('Total lines:', lines.length);

            try {
                lines.forEach((line, idx) => {
                    const trimmed = line.trim();
                    if (!trimmed) {
                        console.log(`Line ${idx + 1}: Empty line (skipped)`);
                        return;
                    }

                    // Split by tab (most common in spreadsheets)
                    const parts = trimmed.split('\t');
                    
                    console.log(`Line ${idx + 1}: ${parts.length} columns detected`);
                    console.log(`  Full line: "${trimmed.substring(0, 100)}..."`);
                    
                    // Skip header row if it contains "Asset" or "Ticker"
                    if (isFirstLine && (trimmed.includes('Asset') || trimmed.includes('Ticker'))) {
                        isFirstLine = false;
                        console.log(`  -> Header row detected and skipped`);
                        debugInfo.push(`Line ${idx + 1}: Header (skipped)`);
                        return;
                    }
                    isFirstLine = false;

                    // Handle different formats:
                    // Format 1: Full spreadsheet with columns: Asset, Ticker, Platform, Type, Units, Total Investment, Active Investment, Avg Unit Price, Last Movement
                    // Format 2: Simple format: Ticker, Units, Price
                    
                    if (parts.length >= 8) {
                        // Full format from user's spreadsheet
                        const assetName = parts[0] ? parts[0].trim() : '';
                        const symbol = parts[1] ? parts[1].trim().toUpperCase() : '';
                        const platform = parts[2] ? parts[2].trim() : 'Unknown';
                        const assetType = parts[3] ? parts[3].trim() : 'Other';
                        const sharesRaw = parts[4] ? parts[4].trim() : '';
                        const shares = parseFloat(sharesRaw);
                        const priceRaw = parts[7] ? parts[7].trim() : '';
                        const avgPrice = parseFloat(priceRaw.replace(/[$,]/g, ''));

                        console.log(`  Parsed: Name="${assetName}", Symbol="${symbol}", Platform="${platform}", Type="${assetType}", Shares="${sharesRaw}" (${shares}), Price="${priceRaw}" (${avgPrice})`);

                        if (symbol && !isNaN(shares) && !isNaN(avgPrice) && shares > 0 && avgPrice > 0) {
                            newPositions.push({ name: assetName, symbol, platform, type: assetType, shares, avgPrice });
                            console.log(`  ‚úì SUCCESS: Added ${symbol} (${assetName}) on ${platform}`);
                            debugInfo.push(`Line ${idx + 1}: ‚úì ${symbol} - ${shares} @ $${avgPrice} (${platform})`);
                        } else {
                            const reason = [];
                            if (!symbol) reason.push('missing ticker');
                            if (isNaN(shares) || shares <= 0) reason.push(`invalid shares (${sharesRaw})`);
                            if (isNaN(avgPrice) || avgPrice <= 0) reason.push(`invalid price (${priceRaw})`);
                            const errorMsg = `Line ${idx + 1}: ‚úó Failed - ${reason.join(', ')}`;
                            errors.push(errorMsg);
                            debugInfo.push(errorMsg);
                            console.log(`  ‚úó FAILED: ${reason.join(', ')}`);
                        }
                    } else if (parts.length >= 3) {
                        // Simple format: Ticker Shares Price
                        const symbol = parts[0].toUpperCase();
                        const shares = parseFloat(parts[1]);
                        const avgPrice = parseFloat(parts[2].replace(/[$,]/g, ''));

                        console.log(`  Simple format: Symbol="${symbol}", Shares=${shares}, Price=${avgPrice}`);

                        if (symbol && !isNaN(shares) && !isNaN(avgPrice)) {
                            newPositions.push({ name: symbol, symbol, platform: 'Unknown', type: 'Stock', shares, avgPrice });
                            console.log(`  ‚úì SUCCESS: Added ${symbol}`);
                            debugInfo.push(`Line ${idx + 1}: ‚úì ${symbol}`);
                        } else {
                            const errorMsg = `Line ${idx + 1}: ‚úó Invalid simple format`;
                            errors.push(errorMsg);
                            debugInfo.push(errorMsg);
                            console.log(`  ‚úó FAILED: Invalid data`);
                        }
                    } else {
                        const errorMsg = `Line ${idx + 1}: ‚úó Only ${parts.length} columns (need at least 8 for full format or 3 for simple)`;
                        errors.push(errorMsg);
                        debugInfo.push(errorMsg);
                        console.log(`  ‚úó FAILED: Not enough columns`);
                    }
                });

                console.log('=== IMPORT SUMMARY ===');
                console.log(`Successful: ${newPositions.length}`);
                console.log(`Failed: ${errors.length}`);

                // Show detailed report
                let reportMsg = `üìä Import Report:\n\n`;
                reportMsg += `‚úì Successfully parsed: ${newPositions.length} positions\n`;
                reportMsg += `‚úó Failed/Skipped: ${errors.length} lines\n\n`;
                
                if (errors.length > 0) {
                    reportMsg += `--- Errors ---\n`;
                    reportMsg += errors.slice(0, 10).join('\n');
                    if (errors.length > 10) {
                        reportMsg += `\n... and ${errors.length - 10} more errors`;
                    }
                    reportMsg += '\n\n';
                }

                if (newPositions.length === 0) {
                    reportMsg += '\n‚ùå No positions could be imported.\n\n';
                    reportMsg += 'Tip: Make sure your data is tab-separated (copied directly from a spreadsheet).\n';
                    reportMsg += 'Check the browser console (F12) for detailed debugging info.';
                    alert(reportMsg);
                    return;
                }

                reportMsg += `\nFirst 5 positions that will be imported:\n`;
                newPositions.slice(0, 5).forEach(p => {
                    reportMsg += `  ‚Ä¢ ${p.symbol}: ${p.shares} shares @ $${p.avgPrice}\n`;
                });
                
                if (newPositions.length > 5) {
                    reportMsg += `  ... and ${newPositions.length - 5} more\n`;
                }

                alert(reportMsg);

                if (newPositions.length > 0) {
                    // Always overwrite - no confirmation needed
                    portfolio = [...newPositions]; // Create new array to force reactivity
                    console.log('Portfolio OVERWRITTEN with:', portfolio);
                    console.log('First 3 positions:', portfolio.slice(0, 3));

                    // Populate local assetDatabase from imported positions
                    portfolio.forEach(p => {
                        const assetRecord = buildAssetRecord(p);
                        assetDatabase[assetRecord.ticker] = {
                            name: assetRecord.name,
                            ticker: assetRecord.ticker,
                            stockExchange: assetRecord.stock_exchange,
                            sector: assetRecord.sector,
                            currency: assetRecord.currency,
                            assetType: assetRecord.asset_type
                        };
                    });
                    console.log('‚úì Built assetDatabase with', Object.keys(assetDatabase).length, 'assets');

                    // Save to Supabase (if connected) - this also saves assets
                    savePortfolioDB();

                    // Close dialog first
                    closeImportDialog();

                    // Force multiple renders to ensure UI updates
                    renderPortfolio();
                    setTimeout(() => renderPortfolio(), 50);
                    setTimeout(() => renderPortfolio(), 200);
                    
                    // Auto-fetch market prices after import
                    setTimeout(() => {
                        console.log('Auto-fetching market prices...');
                        fetchMarketPrices();
                    }, 500);
                    
                    setTimeout(() => {
                        alert(`‚úì Successfully imported ${newPositions.length} position(s)!\n\nFetching current market prices...`);
                    }, 300);
                }
            } catch (err) {
                console.error('=== IMPORT ERROR ===');
                console.error('Error type:', err.name);
                console.error('Error message:', err.message);
                console.error('Full error:', err);
                console.error('Stack trace:', err.stack);
                alert(`‚ùå Import failed: ${err.message}\n\nCheck the browser console (F12) for details.`);
            }
        }

        function selectPerspective(key) {
            selectedPerspective = key;
            renderPerspectiveTabs();
        }

        function renderAllocationCharts() {
            const allocationSection = document.getElementById('allocationSection');
            const typeChart = document.getElementById('typeAllocationChart');
            const sectorChart = document.getElementById('sectorAllocationChart');

            if (!allocationSection || !typeChart || portfolio.length === 0) {
                if (allocationSection) allocationSection.style.display = 'none';
                return;
            }

            // Calculate total market value
            let totalMarketValue = 0;
            portfolio.forEach(p => {
                const currentPrice = marketPrices[p.symbol];
                const invested = p.shares * p.avgPrice;
                totalMarketValue += currentPrice ? p.shares * currentPrice : invested;
            });

            if (totalMarketValue === 0) {
                allocationSection.style.display = 'none';
                return;
            }

            // Aggregate by type
            const typeAllocation = {};
            portfolio.forEach(p => {
                const assetType = p.type || 'Other';
                const currentPrice = marketPrices[p.symbol];
                const invested = p.shares * p.avgPrice;
                const marketValue = currentPrice ? p.shares * currentPrice : invested;

                if (!typeAllocation[assetType]) {
                    typeAllocation[assetType] = 0;
                }
                typeAllocation[assetType] += marketValue;
            });

            // Aggregate by sector
            const sectorAllocation = {};
            portfolio.forEach(p => {
                const sector = getSector(p.symbol);
                const currentPrice = marketPrices[p.symbol];
                const invested = p.shares * p.avgPrice;
                const marketValue = currentPrice ? p.shares * currentPrice : invested;

                if (!sectorAllocation[sector]) {
                    sectorAllocation[sector] = 0;
                }
                sectorAllocation[sector] += marketValue;
            });

            // Sort by value descending
            const sortedTypes = Object.entries(typeAllocation)
                .sort((a, b) => b[1] - a[1]);

            const sortedSectors = Object.entries(sectorAllocation)
                .sort((a, b) => b[1] - a[1]);

            // Color palette for types
            const typeColors = {
                'Stock': '#3b82f6',
                'ETF': '#8b5cf6',
                'Crypto': '#f59e0b',
                'Bond': '#10b981',
                'REIT': '#ec4899',
                'Commodity': '#f97316',
                'Cash': '#6b7280',
                'Other': '#64748b'
            };

            // Color palette for sectors
            const sectorColors = {
                'Technology': '#3b82f6',
                'Healthcare': '#10b981',
                'Financial': '#f59e0b',
                'Consumer Discretionary': '#ec4899',
                'Consumer Staples': '#8b5cf6',
                'Energy': '#ef4444',
                'Industrials': '#6366f1',
                'Materials': '#f97316',
                'Utilities': '#14b8a6',
                'Real Estate': '#a855f7',
                'Communication': '#06b6d4',
                'Crypto': '#eab308',
                'Index ETF': '#64748b',
                'Tech ETF': '#60a5fa',
                'Bond ETF': '#34d399',
                'Other': '#94a3b8'
            };

            const defaultColors = ['#06b6d4', '#84cc16', '#ef4444', '#a855f7', '#14b8a6', '#eab308'];

            // Render type allocation chart
            let colorIdx = 0;
            typeChart.innerHTML = sortedTypes.map(([type, value]) => {
                const pct = (value / totalMarketValue * 100);
                const color = typeColors[type] || defaultColors[colorIdx++ % defaultColors.length];
                return `
                    <div class="allocation-bar-row">
                        <div class="allocation-bar-label" title="${escapeHTML(type)}">${escapeHTML(type)}</div>
                        <div class="allocation-bar-track">
                            <div class="allocation-bar-fill" style="width: ${pct}%; background: ${color};">
                                ${pct >= 10 ? pct.toFixed(1) + '%' : ''}
                            </div>
                        </div>
                        <div class="allocation-bar-value">${formatCurrency(value)}</div>
                    </div>
                `;
            }).join('');

            // Render sector allocation chart
            if (sectorChart) {
                colorIdx = 0;
                sectorChart.innerHTML = sortedSectors.map(([sector, value]) => {
                    const pct = (value / totalMarketValue * 100);
                    const color = sectorColors[sector] || defaultColors[colorIdx++ % defaultColors.length];
                    return `
                        <div class="allocation-bar-row">
                            <div class="allocation-bar-label" title="${escapeHTML(sector)}">${escapeHTML(sector)}</div>
                            <div class="allocation-bar-track">
                                <div class="allocation-bar-fill" style="width: ${pct}%; background: ${color};">
                                    ${pct >= 10 ? pct.toFixed(1) + '%' : ''}
                                </div>
                            </div>
                            <div class="allocation-bar-value">${formatCurrency(value)}</div>
                        </div>
                    `;
                }).join('');
            }

            allocationSection.style.display = 'block';
        }

        function renderPerspectiveTabs() {
            const tabsContainer = document.getElementById('perspectiveTabs');
            const infoContainer = document.getElementById('perspectiveInfo');
            if (!tabsContainer || !infoContainer) return;

            tabsContainer.innerHTML = Object.entries(INVESTMENT_PERSPECTIVES).map(([key, p]) => `
                <div class="perspective-tab ${key === selectedPerspective ? 'active' : ''}"
                     style="${key === selectedPerspective ? `border-color: ${p.color}; box-shadow: 0 0 8px ${p.color}40;` : ''}"
                     onclick="selectPerspective('${key}')">
                    <span>${p.icon}</span>
                    <span>${p.name}</span>
                </div>
            `).join('');

            const active = INVESTMENT_PERSPECTIVES[selectedPerspective];
            infoContainer.innerHTML = `
                <span class="perspective-info-icon">${active.icon}</span>
                <div class="perspective-info-text">
                    <div class="perspective-info-name" style="color: ${active.color};">${active.name}</div>
                    <div class="perspective-info-desc">${active.description}</div>
                    <div class="perspective-info-figures">Key figures: ${active.figures}</div>
                </div>
            `;
        }

        async function analyzeMarkets() {
            const analyzeBtn = document.getElementById('analyzeBtn');
            const analysisSection = document.getElementById('analysisSection');

            const perspective = INVESTMENT_PERSPECTIVES[selectedPerspective];
            console.log('=== ANALYZE MARKETS DEBUG ===');
            console.log('Selected perspective:', selectedPerspective, perspective.name);
            console.log('Portfolio:', portfolio);
            console.log('Portfolio length:', portfolio.length);

            if (portfolio.length === 0) {
                alert('‚ùå No positions in portfolio. Import your portfolio first.');
                return;
            }

            // Determine if we're inside Claude.ai
            const isClaudeAI = window.location.hostname.includes('claude.ai') ||
                              window.location.hostname.includes('anthropic.com') ||
                              (typeof window.storage !== 'undefined');

            // Determine which path to use:
            // 1. User's own Anthropic key (direct call)
            // 2. Claude.ai runtime (direct call, runtime handles auth)
            // 3. Supabase Edge Function (server-side key)
            const useDirectAPI = isClaudeAI || anthropicKey;
            const useEdgeFunction = !useDirectAPI && supabaseUrl;

            if (!useDirectAPI && !useEdgeFunction) {
                analysisSection.innerHTML = `
                    <div class="card" style="background: #334155; padding: 20px;">
                        <h3 style="color: #cbd5e1; margin-bottom: 10px;">ü§ñ AI Analysis</h3>
                        <p style="color: #94a3b8; margin-bottom: 15px;">
                            AI analysis requires either a Supabase connection or your own Anthropic API key.
                        </p>
                        <ol style="color: #94a3b8; margin-left: 20px; line-height: 1.8;">
                            <li>Get an API key from <a href="https://console.anthropic.com/settings/keys" target="_blank" style="color: #60a5fa;">console.anthropic.com</a></li>
                            <li>Click the <strong style="color: #cbd5e1;">üîë API Keys</strong> button above</li>
                            <li>Enter your Anthropic key and save</li>
                            <li>Click "Get AI Analysis" again</li>
                        </ol>
                    </div>
                `;
                return;
            }

            analyzeBtn.disabled = true;
            analyzeBtn.textContent = 'Analyzing...';

            analysisSection.innerHTML = `<div class="card loading">${perspective.icon} Analyzing through ${escapeHTML(perspective.name)} lens...</div>`;

            try {
                let data;

                if (useDirectAPI) {
                    // Direct Anthropic API call (Claude.ai or user's own key)
                    console.log('Using direct Anthropic API...');
                    const headers = { 'Content-Type': 'application/json' };
                    if (!isClaudeAI && anthropicKey) {
                        headers['x-api-key'] = anthropicKey;
                        headers['anthropic-version'] = '2023-06-01';
                        headers['anthropic-dangerous-direct-browser-access'] = 'true';
                    }

                    const response = await fetch('https://api.anthropic.com/v1/messages', {
                        method: 'POST',
                        headers: headers,
                        body: JSON.stringify({
                            model: 'claude-sonnet-4-20250514',
                            max_tokens: 2500,
                            messages: [{
                                role: 'user',
                                content: `${perspective.prompt}

The portfolio contains: ${portfolio.map(p => `${p.shares} shares of ${p.symbol} at avg price $${p.avgPrice}${marketPrices[p.symbol] ? ` (current: $${marketPrices[p.symbol]})` : ''}`).join(', ')}.

Please provide your analysis in JSON format with these fields:
- marketNews: an OBJECTIVE, perspective-neutral overview of current market conditions and recent notable events affecting equities, bonds, or macro (3-5 sentences). This section should be purely factual ‚Äî no opinion from any investment philosophy.
- marketOverview: your OPINIONATED assessment of these market conditions strictly through the lens of ${perspective.name}. Explain what a ${perspective.name} practitioner would focus on and how they would interpret current conditions (3-4 sentences). Make it clear this is a ${perspective.name} perspective.
- portfolioImpact: evaluate the specific holdings in this portfolio through the ${perspective.name} lens ‚Äî which positions align well with this philosophy, which don't, and why (3-4 sentences). Be specific about individual holdings.
- trades: array of exactly 5 concrete trade ideas that a ${perspective.name} investor would make. Each trade MUST have ALL of these fields:
  - "ticker": the stock/ETF ticker symbol (e.g. "AAPL", "VTI", "BRK.B")
  - "action": exactly one of "BUY", "SELL", "HOLD", "TRIM", or "ADD"
  - "title": short trade idea title (e.g. "Accumulate undervalued energy major")
  - "rationale": 2-3 sentence explanation of why this specific trade fits the ${perspective.name} philosophy and current market conditions

Respond ONLY with valid JSON, no markdown, no preamble.`
                            }]
                        })
                    });

                    if (!response.ok) {
                        const errBody = await response.text().catch(() => '');
                        if (response.status === 401) {
                            throw new Error('Invalid API key. Check your Anthropic key in API Keys settings.');
                        }
                        throw new Error(`API returned status ${response.status}: ${errBody}`);
                    }

                    data = await response.json();
                } else {
                    // Supabase Edge Function (server-side Anthropic key)
                    console.log('Using Supabase Edge Function...');

                    const { data: { session } } = await supabaseClient.auth.getSession();
                    const response = await fetch(`${supabaseUrl}/functions/v1/analyze-portfolio`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'apikey': supabaseAnonKey,
                            'Authorization': `Bearer ${session?.access_token || supabaseAnonKey}`
                        },
                        body: JSON.stringify({
                            portfolio: portfolio.map(p => ({
                                shares: p.shares,
                                symbol: p.symbol,
                                avgPrice: p.avgPrice,
                                currentPrice: marketPrices[p.symbol] || null
                            })),
                            perspective: {
                                key: selectedPerspective,
                                name: perspective.name,
                                prompt: perspective.prompt
                            }
                        })
                    });

                    const responseBody = await response.text();
                    console.log('Edge Function response:', response.status, responseBody);

                    if (!response.ok) {
                        throw new Error(`Edge Function error (${response.status}): ${responseBody}`);
                    }

                    data = JSON.parse(responseBody);
                }

                console.log('API Response data:', data);

                const text = data.content.find(c => c.type === 'text')?.text || '';
                console.log('Extracted text:', text);

                const cleanText = text.replace(/```json|```/g, '').trim();
                console.log('Cleaned text:', cleanText);

                const analysis = JSON.parse(cleanText);
                console.log('Parsed analysis:', analysis);

                const actionColors = { BUY: '#4ade80', SELL: '#f87171', HOLD: '#94a3b8', TRIM: '#fbbf24', ADD: '#60a5fa' };
                const actionIcons = { BUY: 'üü¢', SELL: 'üî¥', HOLD: '‚ö™', TRIM: 'üü°', ADD: 'üîµ' };
                const trades = analysis.trades || analysis.ideas || [];

                analysisSection.innerHTML = `
                    <div class="card analysis-section">
                        <div class="analysis-card market-news-card">
                            <div class="analysis-title">üì∞ Market News Overview</div>
                            <div class="analysis-content">${escapeHTML(analysis.marketNews || analysis.marketOverview)}</div>
                        </div>
                    </div>

                    <div class="card analysis-section">
                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;">
                            <span class="perspective-badge" style="background: ${perspective.color};">
                                ${perspective.icon} ${escapeHTML(perspective.name)}
                            </span>
                            <span style="color: #64748b; font-size: 12px;">Inspired by ${escapeHTML(perspective.figures)}</span>
                        </div>

                        <div class="analysis-card" style="border-left: 3px solid ${perspective.color};">
                            <div class="analysis-title">${perspective.icon} Market Assessment ‚Äî ${escapeHTML(perspective.name)} View</div>
                            <div class="analysis-content">${escapeHTML(analysis.marketOverview)}</div>
                        </div>

                        <div class="analysis-card" style="border-left: 3px solid ${perspective.color};">
                            <div class="analysis-title">üéØ Portfolio Evaluation ‚Äî ${escapeHTML(perspective.name)} View</div>
                            <div class="analysis-content">${escapeHTML(analysis.portfolioImpact)}</div>
                        </div>

                        <div class="analysis-card">
                            <div class="analysis-title">üíπ Trade Ideas ‚Äî ${escapeHTML(perspective.name)}</div>
                            ${trades.map((trade, idx) => {
                                const action = (trade.action || '').toUpperCase();
                                const color = actionColors[action] || '#94a3b8';
                                const icon = actionIcons[action] || '‚ö™';
                                const ticker = trade.ticker || '';
                                const rationale = trade.rationale || trade.description || '';
                                return `
                                <div class="trade-idea">
                                    <div class="trade-idea-header">
                                        ${ticker ? `<span class="trade-ticker">${escapeHTML(ticker)}</span>` : ''}
                                        ${action ? `<span class="trade-action" style="background: ${color}20; color: ${color}; border: 1px solid ${color}40;">
                                            ${icon} ${escapeHTML(action)}
                                        </span>` : ''}
                                    </div>
                                    <div class="trade-title">${idx + 1}. ${escapeHTML(trade.title)}</div>
                                    <div class="trade-rationale">${escapeHTML(rationale)}</div>
                                </div>`;
                            }).join('')}
                        </div>

                        <div class="disclaimer">
                            <strong>Disclaimer:</strong> This analysis is generated from a ${escapeHTML(perspective.name)} perspective for educational purposes only. It should not be considered financial advice. Always consult with a qualified financial advisor before making investment decisions.
                        </div>
                    </div>
                `;

                console.log('‚úì Analysis rendered successfully');
            } catch (err) {
                console.error('=== ANALYZE MARKETS ERROR ===');
                console.error('Error type:', err.name);
                console.error('Error message:', err.message);
                console.error('Full error:', err);
                console.error('Stack trace:', err.stack);

                analysisSection.innerHTML = `
                    <div class="card">
                        <div class="analysis-content" style="color: #f87171;">
                            ‚ùå Unable to generate analysis: ${escapeHTML(err.message)}
                            <br><br>
                            Check the browser console (F12) for detailed error information.
                        </div>
                    </div>
                `;

                alert(`‚ùå Error generating analysis:\n\n${err.message}\n\nCheck console (F12) for details.`);
            }

            analyzeBtn.disabled = false;
            analyzeBtn.textContent = 'Get AI Analysis';
        }

        async function getTradeIdeas() {
            const tradeIdeasBtn = document.getElementById('tradeIdeasBtn');
            const analysisSection = document.getElementById('analysisSection');
            const perspective = INVESTMENT_PERSPECTIVES[selectedPerspective];

            console.log('=== GET TRADE IDEAS DEBUG ===');
            console.log('Selected perspective:', selectedPerspective, perspective.name);

            if (portfolio.length === 0) {
                alert('‚ùå No positions in portfolio. Import your portfolio first.');
                return;
            }

            tradeIdeasBtn.disabled = true;
            tradeIdeasBtn.textContent = 'Generating...';

            const today = new Date().toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
            analysisSection.innerHTML = `<div class="card loading">üíπ Generating concrete trade ideas for ${today}...</div>`;

            // Determine which path to use (same logic as analyzeMarkets)
            const isClaudeAI = window.location.hostname.includes('claude.ai') ||
                              window.location.hostname.includes('claude.site') ||
                              (typeof window.anthropic !== 'undefined');
            const useDirectAPI = isClaudeAI || anthropicKey;
            const useEdgeFunction = !useDirectAPI && supabaseUrl;

            if (!useDirectAPI && !useEdgeFunction) {
                analysisSection.innerHTML = `
                    <div class="card" style="background: #334155; padding: 20px;">
                        <h3 style="color: #cbd5e1; margin-bottom: 10px;">üíπ Trade Ideas</h3>
                        <p style="color: #94a3b8; margin-bottom: 15px;">
                            Trade ideas require either a Supabase connection or your own Anthropic API key.
                        </p>
                        <ol style="color: #94a3b8; margin-left: 20px; line-height: 1.8;">
                            <li>Get an API key from <a href="https://console.anthropic.com/settings/keys" target="_blank" style="color: #60a5fa;">console.anthropic.com</a></li>
                            <li>Click the <strong style="color: #cbd5e1;">üîë API Keys</strong> button above</li>
                            <li>Enter your Anthropic key and save</li>
                            <li>Click "Get Trade Ideas" again</li>
                        </ol>
                    </div>
                `;
                tradeIdeasBtn.disabled = false;
                tradeIdeasBtn.textContent = 'üíπ Get Trade Ideas';
                return;
            }

            try {
                let data;
                const portfolioSummary = portfolio.map(p => {
                    const currentPrice = marketPrices[p.symbol];
                    const invested = p.shares * p.avgPrice;
                    const marketValue = currentPrice ? p.shares * currentPrice : invested;
                    const gainLoss = marketValue - invested;
                    const gainLossPct = invested > 0 ? ((gainLoss / invested) * 100).toFixed(1) : 0;
                    return `${p.symbol}: ${p.shares} shares @ $${p.avgPrice} avg${currentPrice ? `, current $${currentPrice} (${gainLoss >= 0 ? '+' : ''}${gainLossPct}%)` : ''}, type: ${p.type || 'Stock'}`;
                }).join('\n');

                const tradeIdeasPrompt = `You are a ${perspective.name} investment advisor (inspired by ${perspective.figures}). Today is ${today}.

${perspective.prompt}

The user's current portfolio:
${portfolioSummary}

Based on current market conditions and this portfolio, provide 3-4 CONCRETE, ACTIONABLE trade ideas for TODAY that align with the ${perspective.name} philosophy.

For each trade idea, provide:
1. A clear action type (REBALANCE, BUY, SELL, TRIM, ADD, or WATCH)
2. Specific ticker symbol(s) involved
3. Current market context (recent price action, news, technical signals relevant to this perspective)
4. The specific action to take (exact percentages, price levels, limit orders)
5. Rationale explaining why this trade fits the ${perspective.name} philosophy

Also provide a brief "Today's Execution Plan" with timing suggestions (Morning, Mid-Day, Afternoon, End of Day).

Respond in JSON format:
{
  "date": "${today}",
  "perspective": "${perspective.name}",
  "marketSummary": "Brief 2-3 sentence overview of today's market conditions",
  "trades": [
    {
      "action": "BUY|SELL|TRIM|ADD|REBALANCE|WATCH",
      "title": "Short descriptive title",
      "subtitle": "One-line trade summary with tickers",
      "tickers": ["TICKER1", "TICKER2"],
      "context": ["bullet point 1 about current conditions", "bullet point 2", "bullet point 3"],
      "specificAction": "Detailed description of exactly what to do",
      "rationale": "Why this fits the ${perspective.name} philosophy"
    }
  ],
  "executionPlan": [
    {"time": "Morning", "action": "What to do in the morning"},
    {"time": "Mid-Day", "action": "What to do mid-day"},
    {"time": "Afternoon", "action": "What to do in the afternoon"}
  ]
}

Respond ONLY with valid JSON, no markdown, no preamble.`;

                if (useDirectAPI) {
                    console.log('Using direct Anthropic API for trade ideas...');
                    const headers = { 'Content-Type': 'application/json' };
                    if (!isClaudeAI && anthropicKey) {
                        headers['x-api-key'] = anthropicKey;
                        headers['anthropic-version'] = '2023-06-01';
                        headers['anthropic-dangerous-direct-browser-access'] = 'true';
                    }

                    const response = await fetch('https://api.anthropic.com/v1/messages', {
                        method: 'POST',
                        headers: headers,
                        body: JSON.stringify({
                            model: 'claude-sonnet-4-20250514',
                            max_tokens: 4000,
                            messages: [{ role: 'user', content: tradeIdeasPrompt }]
                        })
                    });

                    if (!response.ok) {
                        const errBody = await response.text().catch(() => '');
                        if (response.status === 401) {
                            throw new Error('Invalid API key. Check your Anthropic key in API Keys settings.');
                        }
                        throw new Error(`API returned status ${response.status}: ${errBody}`);
                    }

                    data = await response.json();
                } else {
                    // Supabase Edge Function
                    console.log('Using Supabase Edge Function for trade ideas...');

                    const { data: { session } } = await supabaseClient.auth.getSession();
                    const response = await fetch(`${supabaseUrl}/functions/v1/analyze-portfolio`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'apikey': supabaseAnonKey,
                            'Authorization': `Bearer ${session?.access_token || supabaseAnonKey}`
                        },
                        body: JSON.stringify({
                            portfolio: portfolio.map(p => ({
                                shares: p.shares,
                                symbol: p.symbol,
                                avgPrice: p.avgPrice,
                                currentPrice: marketPrices[p.symbol] || null,
                                type: p.type || 'Stock'
                            })),
                            perspective: {
                                key: selectedPerspective,
                                name: perspective.name,
                                prompt: tradeIdeasPrompt
                            },
                            requestType: 'tradeIdeas'
                        })
                    });

                    if (!response.ok) {
                        const errBody = await response.text().catch(() => '');
                        throw new Error(`Edge function returned ${response.status}: ${errBody}`);
                    }

                    data = await response.json();
                }

                const text = data.content.find(c => c.type === 'text')?.text || '';
                const cleanText = text.replace(/```json|```/g, '').trim();
                const ideas = JSON.parse(cleanText);

                console.log('Parsed trade ideas:', ideas);

                const actionColors = {
                    'BUY': '#10b981',
                    'SELL': '#ef4444',
                    'TRIM': '#f59e0b',
                    'ADD': '#3b82f6',
                    'REBALANCE': '#f59e0b',
                    'WATCH': '#8b5cf6',
                    'HOLD': '#6366f1'
                };

                const actionIcons = {
                    'BUY': 'üü¢',
                    'SELL': 'üî¥',
                    'TRIM': 'üü°',
                    'ADD': 'üîµ',
                    'REBALANCE': 'üìä',
                    'WATCH': 'üëÅÔ∏è',
                    'HOLD': '‚è∏Ô∏è'
                };

                analysisSection.innerHTML = `
                    <div class="card trade-ideas-section">
                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;">
                            <span class="perspective-badge" style="background: ${perspective.color};">
                                ${perspective.icon} ${escapeHTML(perspective.name)}
                            </span>
                            <span style="color: #94a3b8; font-size: 12px;">${escapeHTML(ideas.date || today)}</span>
                        </div>

                        <div style="background: #1e293b; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                            <div style="color: #94a3b8; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 8px;">Market Summary</div>
                            <div style="color: #e2e8f0; font-size: 14px; line-height: 1.6;">${escapeHTML(ideas.marketSummary || '')}</div>
                        </div>

                        <h3 style="color: #e2e8f0; font-size: 18px; margin-bottom: 15px;">üíπ Concrete Trade Ideas</h3>

                        ${(ideas.trades || []).map((trade, idx) => {
                            const action = (trade.action || 'WATCH').toUpperCase();
                            const color = actionColors[action] || '#6366f1';
                            const icon = actionIcons[action] || 'üìã';
                            const cardClass = action.toLowerCase();
                            return `
                            <div class="trade-idea-card ${cardClass}">
                                <div class="trade-idea-header">
                                    <div class="trade-idea-number" style="background: ${color}20; color: ${color};">${idx + 1}</div>
                                    <div class="trade-idea-title-section">
                                        <div class="trade-idea-title">${icon} ${escapeHTML(trade.title || '')}</div>
                                        <div class="trade-idea-subtitle">${escapeHTML(trade.subtitle || '')}</div>
                                    </div>
                                </div>

                                ${trade.context && trade.context.length > 0 ? `
                                <div class="trade-idea-context">
                                    <h4>Current Context</h4>
                                    <ul>
                                        ${trade.context.map(c => `<li>${escapeHTML(c)}</li>`).join('')}
                                    </ul>
                                </div>
                                ` : ''}

                                <div class="trade-idea-action">
                                    <h4>üéØ Specific Action</h4>
                                    <p>${escapeHTML(trade.specificAction || '')}</p>
                                </div>

                                <div class="trade-idea-rationale">
                                    <strong>Rationale:</strong> ${escapeHTML(trade.rationale || '')}
                                </div>
                            </div>
                            `;
                        }).join('')}

                        ${ideas.executionPlan && ideas.executionPlan.length > 0 ? `
                        <div class="trade-ideas-summary">
                            <h3>üìã Today's Execution Plan</h3>
                            ${ideas.executionPlan.map(step => `
                                <div class="execution-step">
                                    <span class="execution-time">${escapeHTML(step.time || '')}</span>
                                    <span class="execution-action">${escapeHTML(step.action || '')}</span>
                                </div>
                            `).join('')}
                        </div>
                        ` : ''}

                        <div class="disclaimer" style="margin-top: 20px;">
                            <strong>Disclaimer:</strong> These trade ideas are generated from a ${escapeHTML(perspective.name)} perspective for educational purposes only. They are not personalized financial advice. Always do your own research and consult with a qualified financial advisor before making investment decisions. Past performance does not guarantee future results.
                        </div>
                    </div>
                `;

                console.log('‚úì Trade ideas rendered successfully');
            } catch (err) {
                console.error('=== GET TRADE IDEAS ERROR ===');
                console.error('Error:', err.message);

                analysisSection.innerHTML = `
                    <div class="card">
                        <div class="analysis-content" style="color: #f87171;">
                            ‚ùå Unable to generate trade ideas: ${escapeHTML(err.message)}
                        </div>
                    </div>
                `;
            }

            tradeIdeasBtn.disabled = false;
            tradeIdeasBtn.textContent = 'üíπ Get Trade Ideas';
        }

        renderPortfolio();
        renderPerspectiveTabs();

        // Global error handler with detailed logging
        window.onerror = function(message, source, lineno, colno, error) {
            console.error('=== GLOBAL ERROR CAUGHT ===');
            console.error('Message:', message);
            console.error('Source:', source);
            console.error('Line:', lineno, 'Column:', colno);
            console.error('Error object:', error);
            
            // Show alert for all errors so user knows what's happening
            if (message && message !== 'Script error.') {
                alert('JavaScript Error:\n\n' + message + '\n\nLine: ' + lineno + '\n\nCheck console (F12) for details.');
            } else {
                // Generic script error - likely from external resource
                console.warn('Generic "Script error." caught - this usually means a CORS issue or blocked resource');
                alert('A script error occurred. This is usually harmless.\n\nIf features are not working:\n1. Open Console (F12)\n2. Look for detailed error messages\n3. Try refreshing the page');
            }
            
            return true; // Prevent default error handling
        };
        
        // Promise rejection handler
        window.onunhandledrejection = function(event) {
            console.error('=== UNHANDLED PROMISE REJECTION ===');
            console.error('Reason:', event.reason);
            console.error('Promise:', event.promise);
            alert('Async Error:\n\n' + (event.reason || 'Unknown error') + '\n\nCheck console (F12) for details.');
        };
        
        // Load portfolio history from localStorage
        const storedHistory = localStorage.getItem('portfolioHistory');
        if (storedHistory) {
            try {
                portfolioHistory = JSON.parse(storedHistory);
                console.log('Loaded portfolio history from localStorage:', portfolioHistory.length, 'snapshots');
                updateHistoryDisplay();
            } catch (err) {
                console.error('Error loading history:', err);
            }
        }
        
        // Load from Claude cloud storage (if available)
        (async () => {
            if (typeof window.storage !== 'undefined') {
                try {
                    console.log('‚òÅÔ∏è Cloud storage available, loading portfolio...');
                    
                    // Load current portfolio
                    const portfolioData = await window.storage.get('current-portfolio', false);
                    if (portfolioData && portfolioData.value) {
                        const data = JSON.parse(portfolioData.value);
                        if (data.portfolio && data.portfolio.length > 0) {
                            portfolio = data.portfolio;
                            marketPrices = data.marketPrices || {};
                            priceMetadata = data.priceMetadata || {};
                            console.log('‚úì Loaded portfolio from cloud:', portfolio.length, 'positions');
                            console.log('Last updated:', data.lastUpdated);
                            renderPortfolio();
                        }
                    }
                    
                    // Load all snapshots
                    const snapshotKeys = await window.storage.list('snapshot:', false);
                    if (snapshotKeys && snapshotKeys.keys && snapshotKeys.keys.length > 0) {
                        console.log('‚úì Found', snapshotKeys.keys.length, 'snapshots in cloud');
                        
                        // Load each snapshot
                        const cloudSnapshots = [];
                        for (const key of snapshotKeys.keys) {
                            try {
                                const result = await window.storage.get(key, false);
                                if (result && result.value) {
                                    const snapshot = JSON.parse(result.value);
                                    cloudSnapshots.push(snapshot);
                                }
                            } catch (err) {
                                console.warn('Failed to load snapshot:', key, err);
                            }
                        }
                        
                        // Merge with localStorage history (avoid duplicates by timestamp)
                        const existingTimestamps = new Set(portfolioHistory.map(s => s.timestamp));
                        cloudSnapshots.forEach(snapshot => {
                            if (!existingTimestamps.has(snapshot.timestamp)) {
                                portfolioHistory.push(snapshot);
                            }
                        });
                        
                        // Sort by timestamp
                        portfolioHistory.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                        
                        console.log('‚úì Total history:', portfolioHistory.length, 'snapshots');
                        updateHistoryDisplay();
                    }
                    
                    alert(`‚òÅÔ∏è Cloud storage loaded!\n\n${portfolio.length} positions\n${portfolioHistory.length} historical snapshots\n\nYour portfolio syncs across all devices where you use Claude.`);
                } catch (err) {
                    console.warn('Cloud storage not available or failed to load:', err);
                    console.log('Using localStorage only');
                }
            } else {
                console.log('Cloud storage not available (open in claude.ai for sync)');
            }
        })();
        
        // Load API key overrides from localStorage (defaults are hardcoded)
        const storedAVKey = localStorage.getItem('alphaVantageKey');
        if (storedAVKey) { alphaVantageKey = storedAVKey; }

        const storedFHKey = localStorage.getItem('finnhubKey');
        if (storedFHKey) { finnhubKey = storedFHKey; }

        const storedFMPKey = localStorage.getItem('fmpKey');
        if (storedFMPKey) { fmpKey = storedFMPKey; }

        const storedAntKey = localStorage.getItem('anthropicKey');
        if (storedAntKey) { anthropicKey = storedAntKey; }

        console.log('‚úì API keys ready (hardcoded defaults + localStorage overrides)');

        // Load sector cache from localStorage
        loadSectorCache();
        console.log('‚úì Sector cache loaded');

        // Load Supabase config overrides from localStorage (if user changed them)
        const storedSBUrl = localStorage.getItem('supabaseUrl');
        const storedSBKey = localStorage.getItem('supabaseAnonKey');
        if (storedSBUrl && storedSBKey) {
            supabaseUrl = storedSBUrl;
            supabaseAnonKey = storedSBKey;
            console.log('‚úì Supabase config overridden from localStorage');
        }
        // Always initialize ‚Äî defaults are hardcoded
        initSupabase();

        console.log('=== APP INITIALIZED ===');
        console.log('API Keys:', { finnhub: !!finnhubKey, fmp: !!fmpKey, alphaVantage: !!alphaVantageKey, anthropic: !!anthropicKey });
        console.log('Supabase:', { configured: !!(supabaseUrl && supabaseAnonKey) });
        console.log('Portfolio positions:', portfolio.length);
        console.log('History snapshots:', portfolioHistory.length);
        console.log('Is Artifact:', isArtifact);
        console.log('Cloud Storage Available:', typeof window.storage !== 'undefined');

        // Show artifact warning if detected
        if (isArtifact) {
            const warningDiv = document.getElementById('artifactWarning');
            if (warningDiv) {
                warningDiv.style.display = 'block';
            }
        }
        
        // Auto-fetch prices if portfolio exists and any API key is set
        if (portfolio.length > 0 && (finnhubKey || fmpKey || alphaVantageKey)) {
            console.log('Auto-fetching prices on page load...');
            setTimeout(() => {
                fetchMarketPrices();
            }, 1000); // Wait 1 second after page load
        }
    </script>
</body>
</html>
